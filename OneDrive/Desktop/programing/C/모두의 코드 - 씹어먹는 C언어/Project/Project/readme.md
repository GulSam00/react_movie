## 목차

### OT

#### C언어란 무엇인가

* C언어가 왜 어렵나
- C언어의 문법 자체는 48년 전과 별반 차이가 없음
- 그러나 컴퓨터의 기능, 용량이 천지차이

* 왜 배워야 하는가
- 한 번 제대로 배워놓으면 오래 써먹을 수 있음
- C언어에 기반으로 하는 언어들이 많음
- 추상화의 정도가 작음 (자동차 수동 운전) - 해야 할 것이 많은 반면 여러 가지를 제어 가능

- 컴퓨터의 작동 원리를 잘 아면 C언어를 이해하기 쉬움 -> 컴퓨터의 작동 원리에 대한 이해가 필요

---

#### 컴퓨터란 무엇인가

* 일련의 연산을 수행하는 계산기
* 명령어를 읽어들여서 주어진 명령어에 따라 연산

1. 누가 명령어를 읽는가?
2. 어디서 명령어를 읽는가?
3. 프로그램이란게 뭐지?
4. 명령어는 어떻게 작성하는가?

---

#### 누가 명령어를 읽는가

* 컴퓨터의 모든 연산은 중앙 처리 장치, CPU (Central Processing Unit) 이라 불리는 작은 반도체에 의해서 처리.

* CPU 는 1초에 약 10억번 개의 연산을 처리, 엄청난 양의 열을 발생. 쿨러가 바로 CPU를 식혀주는 역할을 함.

* 최근에는 그래픽 관련 연산을 전문적으로 처리하는 GPU라는 장치가 있으나 CPU처럼 다양한 종류의 명령어 처리는 불가. 범용적인 명령어는 전부 CPU 관할

---

#### 어디서 명령어를 읽는가

* 명령어를 실행
1. 실행할 명령어를 읽어야 함
2. 연산된 결과를 저장해야 함

* CPU에 명령어와 연산한 결과를 저장하기에는 연산에 특화된 장치기에 공간이 매우 부족

##### 레지스터

* CPU가 연산을 수행하기 위해 데이터를 저장하는 공간을 레지스터(register)라고 부름. 64비트 CPU기준으로 16개, 각 레지스터는 64비트의 데이터 저장 가능. CPU에 저장할 수 있는 데이터는 최대 128바이트.

* 기술 한계상 레지스터의 개수를 늘릴 수는 없기에 CPU 밖 저장공간이 필요함.

##### 램

* CPU 바로 옆에서 저장 공간 역할을 하는 장치가 바로 램(RAM, Random Access Memory, 임의 접근 메모리)

* CPU의 레지스터(128바이트)보다 6천만 배 큰 용량, CPU는 램에 실행할 명령어나 데이터들을 저장하고 있다 연산을 수행할 때 명령을 램에서 읽어들임.

##### HDD, SSD

* 램은 전기가 있을 경우에만 유지되는 휘발성 메모리. 전원이 끊기면 메모리의 데이터는 모두 날아간다.

* 컴퓨터가 꺼져도 데이터를 유지할 수 있는 저장장치, 하드 디스크과 SSD가 등장. 데이터를 읽어들이는 작업은 램에서보다 훨씬 느리지만 전기 공급 없이도 데이터를 안정적으로 보관 가능.

##### 데이터가 이동하는 구조

* 램 -> CPU : 100 나노초
* SSD -> CPU : 5000 ~ 15000 나노초 | 50 ~ 150 마이크로초
* 하드디스크 -> CPU : 1000000 ~ 10000000 나노초 | 1 ~ 10 밀리초
* 평균 0.3 나노초마다 1번 연산을 하는 CPU, 하드 디스크에서 CPU에 데이터가 올 때까지 기다리는 동안 3천만 번의 연산을 수행할 수 있음.

* 컴퓨터 프로그램을 실행
    1. 하드 디스크에 저장되어 있는 프로그램의 위치를 찾아서 램에 복사
    2. CPU는 램에서 명령어를 읽어들여서 실행
        - CPU <-> RAM <-> HDD(하드 디스크) or SSD

##### 캐시

* CPU에서 RAM에 접근하는 속도도 꽤나 길기에 CPU는 빠르게 데이터를 레지스터에 불러올 수 있는 저장 공간으로 캐시(Cache)라는 것을 사용

* 캐시는 계층별로 L1, L2, L3 캐시로 이루어져 있음, L1 캐시의 경우 크기가 제일 작지만 (256KB) 레지스터와 가장 인접한 캐시, 1 나노초 만에 L1 캐시에 저장되어 있는 데이터를 읽을 수 있음. L3 캐시는 28 나노초가 걸리지만 크기가 제일 큼(~16MB)

* 지금 가장 필요한 데이터는 L1 캐시, 필요성이 낮으면 낮을 수록 L2, L3 캐시에 배치.

* 조만간 사용할 것 같은 데이터를 미리 캐시에 불러오거나, 램에 저장하기 직전 임시 보관하는 용도로도 쓰임. 

* 어떤 데이터가 미리 쓰일지 알 수 없기에 CPU는 여러가지 예측 알고리즘을 사용해서 캐시의 적중률을 높이려 함. 램의 전체 데이터를 중구 난방으로 사용하는 것 보다는 특정 부분만 반복적으로 접근하는 경우에 캐시 적중률이 높아짐.

*  CPU가 요청한 데이터가 캐시에 없을 수도 있음. 캐시 미스(Cache miss)시 램에서 필요한 데이터를 불러 오느라 상당히 시간이 지체됨.

#### 명령어는 어떻게 작성하는가?

* CPU 가 램에서 데이터를 읽어들이기 위해서는 램의 어디 에서 데이터를 읽어들일지 알아야 함. 램에 있는 모든 데이터는 1 바이트 단위로 0 번을 시작으로 고유의 주소(address) 가 부여되어 있음.

* 램은 크기가 1 바이트 (2진수로 8 자리수)짜리 데이터를 보관할 수 있는 수 많은 방들로 구성되어 있음. CPU가 램에게 어디에서 데이터를 읽을지 알려주면 램은 해당 위치에 있는 데이터를 즉각 전달. 어디에다 데이터를 저장할지 알려준다면 램은 해당 위치에 있는 데이터를 CPU 가 전달한 데이터로 저장 (덮어쓰기)

* 램 상에서는 데이터의 경계가 없기에 해당 주소값으로 부터 얼마 만큼 읽어야 할지도 지정해야 함. 얼마 만큼 읽어야 할 지는 명령어 단계에서 지정.

* CPU 에게 주소값 0x1234 에 1 바이트 만큼 3 이라는 데이터를 저장하려 함.
    1. CPU 의 레지스터에 접근하고자 하는 주소값 0x1234 를 저장. 편의상 a 라는 레지스터에 저장.
    2. a 에 저장된 주소값에서 부터 1 바이트 부분 까지 3 을 저장하라고 명령.
        - 이와 같이 CPU 가 직접적으로 해석하는 명령어를 어셈블리(Assembly) 라고 함. CPU 는 0 과 1 로 된 전기 신호만을 받아서 해석하지 알파벳 그대로 명령어를 받지 않음. 다만 어셈블리 명령어와 실제 CPU 가 읽어들이는 데이터와 1 대 1 대응이 되어 있기 때문에 (사람이 그나마 읽기 편하도록) 영어 명령어로 바꿔서 표현.
        - 메모리의 주소값에 해당하는 데이터를 접근하기 위해선, 먼저 그 주소값을 레지스터에 집어 넣고 해당 레지스터를 참조해야 함.

`* 64 비트 시스템 CPU 의 레지스터의 크기는 8 바이트. 레지스터에는 주소값을 전달할 수 있어야 하는데, 64 비트 시스템에서 주소값은 8 바이트 이기에 레지스터도 8 바이트가 되는 것.`

`* 8 바이트로는 2^{64} (= 18,446,744,073,709,551,616)2 64 (=18,446,744,073,709,551,616) 개의 수를 표현할 수 있지만엄청나게 큰 수를 표현하기에는 무리가 있음. CPU로 매우 큰 정수의 연산을 다루기 위해서는 수를 8 바이트 단위로 쪼개서 따로따로 연산을 해야겠지요.`

#### CPU 가 명령어를 읽어들이는 방법

* CPU 는 주소값 을 통해서 램에 어디에 접근할지 명령

* CPU 가 독자적으로 명령을 내릴 수 없기에 해당 명령어를 어디선가 가져와야 합니다. 이와 같이 CPU에 실행할 명령어를 제공하는 것을, 쉬운 말로 [프로그램을 실행한다] 라고 함.

* 프로그램은 실행할 명령어와 데이터들의 집합. 프로그램을 실행하게 되면 컴퓨터의 운영체제가 CPU에게 램에 위치해 있는 프로그램의 시작점을 알려주고 그 이후 CPU는 해당 위치 부터 명령어를 읽어나가며 실행.

* 중요한 것은 CPU가 현재 램의 어디에서 명령어를 읽어야 할지 계속 알아야 한다는 것. 이는 CPU 안에 지금 읽어들일 명령어의 위치 (instruction pointer) 만을 보관하는 특별한 레지스터 덕분에 가능. (인텔 64 비트 CPU 의 경우 해당 레지스터의 이름은 RIP) 명령어를 처리한 이후 RIP는 다음 명령어를 가리키는 주소값으로 자동으로 업데이트 됨.

* CPU 는 현재 내가 어떠한 프로그램을 실행하고 있는지 모름. 그저 현재 자신의 RIP 레지스터가 가리키는 위치에 있는 명령어를 실행하고 그 다음 명령어의 위치로 RIP를 증가시킬 뿐 어떠한 프로그램에서 해당 명령어를 실행하는지 모름.

* 스타크래프트를 실행했다 가정. 하드 디스크나 SSD 같은 저장 장치에 있는 스타크래프트 프로그램 파일을 메모리에 복사하는 작업을 운영체제 단에서 해결

* 메모리에는 데이터와 프로그램 명령어를 구분해서 저장하지 않기에 CPU의 관점에서는 메모리의 특정 주소값을 읽을 때 둘을 구별할 수 없음. 운영체제가 알려준 처음으로 실행할 명령어의 위치부터 명령어를 단순하게 쭉 읽어나갈 뿐. 이를 악용한 해킹 기법도 있음.

#### 가상 메모리, 물리 메모리

* 실제 RAM에서는 여러가지 프로그램들이 램의 여러 부분을 나누어서 차지해 실행되고 있을 것.

* 만일 어셈블리 명령어로 램 메모리의 0x1234 (십진수로 4660) 에 위치해 있는 곳에서 4 바이트 만큼의 공간에 3 이라는 값을 쓰라는 명령했다 가정. 그러나 그 시점에 해당 공간에서 프로그램이 실행되고 있다면 데이터를 손상시키게 될 것. 그렇기에 CPU에서 메모리를 조금 더 효율적으로 관리하기 위해 특별한 메커니즘을 제공.

* CPU가 0x1234 에 3 이라는 데이터를 쓰라는 명령을 내리면 메모리의 주소값 0x1234 의 위치에 3을 쓰게된다고 하는 것은 거짓. 이렇게 된다면 앞서 이야기 했던 문제를 해결할 수 없기 때문.

* 실제로 CPU가 보는 0x1234 라는 주소값과 실제 메모리의 0x1234 주소값은 차이가 있음. CPU가 참조하는 0x1234 라는 주소값은 특별한 1 대 1 변환 과정에 의해서 실제 메모리의 주소값을 변환. 이렇게 변환된 주소는 0x1234 가 될 수 도 있고 아니면 아예 0x12345678 처럼 전혀 다른 곳에 있는 메모리 주소값이 될 수 도 있음.

* CPU 가 참조하는 메모리 주소값을 가상 메모리(virtual memory), 일련의 변환 과정에 의해 참조하게될 실제 메모리의 주소값을 물리 메모리(physical memory) 라고 함.

* 이러한 변환 방식을 페이징(paging), 변환이 되는 최소의 메모리 단위를 페이지(page) 라고 함. 페이지의 크기는 대부분의 경우 1 페이지는 4 KB 정도임.

* 어떻게 변환을 수행할 지 기록한 테이블을 페이지 테이블(page table)이라고 함. 이 페이지 테이블은 각 프로그램 마다 하나씩 가지고 있음. 따라서 이 덕분에 따라서 구글 크롬에서의 0x1234 와 그림판의 0x1234 가 실제로는 다른 물리 메모리 주소를 참조할 수 있음.

* 우리가 흔히 사용하는 메모리의 크기는 8 기가 혹은 16 기가 바이트를 주로 사용. 페이징 덕분에 가상 메모리 공간 그 어디에 기록을 해도 페이지 테이블을 통해 현재 내가 사용 가능한 크기 이내의 물리 주소로 변환을 하게 되면 문제 없이 사용 가능

* 경우에 따라선, 메모리의 올라가 있는 전체 프로그램이 필요로 하는 메모리가 지금 내가 가지고 있는 물리 메모리의 용량 보다도 더 큰 경우도 해결 가능. 안쓰는 페이지 부터 하드 디스크에 복사해 놓고, 해당 페이지를 메모리를 필요로 하는 프로그램에 제공을 하는 방법.

* 만약에 하드 디스크에 복사해놓은 페이지를 다시 필요로 한다면, 그 때 운영체제가 해당 페이지를 다시 메모리에 복사해주면 됨. 메모리가 제한된 환경에서는 이와 같은 상황이 빈번하게 일어났음. 옛날 컴퓨터에서 프로그램을 실행했을 때 종종 매우 느려졌던 이유가 바로 물리 메모리가 부족해서 하드 디스크에 복사해 놓은 페이지를 읽어오느라 매우 느렸던 것. (메모리에 비해 하드 디스크는 매우 느림)

* 페이징으로 각 프로그램들은 메모리에 같이 올라가 있는 다른 프로그램들을 전혀 고려할 필요 없이 마치 자기 혼자서 메모리 전 공간을 사용하는 것 마냥 생각할 수 있음.

#### 정리

* 모든 연산은 CPU 에서 수행된다. 정확히 말하자면, CPU 의 자그마한 레지스터 상에서 수행된다. 64 비트 CPU 의 경우 레지스터의 크기는 8 바이트 이다.

* CPU 는 무슨 연산을 할 지 알려주는 명령어와, 명령어를 실행하기 위해 필요로 하는 데이터를 메모리 (램) 에서 읽는다.

* 프로그램을 실행한다는 것은 하드 디스크에 잠들어 있는 명령어들과 데이터를 메모리에 쓰는 것이라 생각하면 된다. 그리고 운영체제가 CPU 에 처음으로 실행해야 할 명령어의 주소값을 전달함으로써 프로그램이 시작된다.

* CPU 에는 캐시가 있어서 메모리 접근 횟수를 줄일 수 있다.

* 각 프로그램들은 마치 자신이 방대한 메모리 공간 전체를 사용하는 것 처럼 생각하며 작동한다.

* CPU 에서 참조하는 주소값은 실제 물리 메모리 주소값이 아니라 가상 메모리 주소값이다.

* 가상 메모리 주소값은 각 프로그램의 페이지 테이블을 통해서 실제 메모리 주소값으로 변환된다.

---

### 1. C언어를 배우는 이유

* 컴퓨터의 내부 원리를 알 수 있음
* 다른 언어를 익히기 쉬움
* 배울 내용이 적음

#### 컴파일러

* 컴파일 : 프로그래밍 언어를 컴퓨터가 이해할 수 있도록 기계어로 바꾸어 주는 역할을 수행하는 것

---

### 2. 코드 분석
```c
#include <stdio.h>
int main() {
  printf("Hello, World! \n");
  return 0;
}
```
* int : 정수(integer)
* main : 함수
* int main : 정수형을 반환하는 메인 함수
* printf : 콘솔 창에 내용을 출력하는 함수
* stdio.h : 표준 입출력 헤더(STandard Input Output header), 입출력을 관장하는 파일을 포함하고 있다.
* return 0 : 0을 운영체제(프로그램을 호출한 프로그램)한테 반환
* 주석 : 코드에 대한 부연 설명, 여러 줄에 걸칠 수 있는 `/* */`와 한줄만 적용되는 `//`가 있다.

#### 기수법

* 수(Number) : 물질의 양을 나타내는 단위
* 숫자(Digit) : 수를 기록할 수 있도록 시각화한 것

* 밑과 지수 : 아래의 수는 밑, 제곱을 나타낸 수는 지수
* (n)의 0제곱은 항상 1이다.

* 253
* 10진법은 자리수가 늘어날 때 마다 그것을 나타나는 숫자에 10이 곱해진다
* 2진법도 마찬가지로 자리수가 늘어날 때마다 2가 곱해진다.
    - 23 = 16 + 4 + 2 + 1 = 10111 (16, 8, 4, 2, 1)
    - 49 = 32 + 16 + 1 = 110001 (32, 16, 8, 4, 2, 1)
* 2진수를 10진수로 : 자리수가 올라갈 때 마다 자리수의 값이 두 배가 된다.
* 10진수를 2진수로 : 10진수를 2로 나누어서 나온 나머지를 몫이 0이 될 때까지 구하고 나머지들만 역순으로 배치하면 된다.

* 이진수는 값이 크기에 프로그래머들은 보통 16진법을 사용.
* 16진법은 숫자가 16개나 필요, 9 다음의 6개의 숫자를 알파벳을 이용해 표현
* 10 : A, 11 : B, 12 : C... 15 : F 방식으로 표현
* 16진수도 한 자리가 늘어날 때마다 16을 곱하면 됨
    - 123 = 7 * 16 + 11 = 0x7B(0x는 16진수임을 의미)
    - 19 = 16 + 3 = 0x13
    - 16782 = 4 * 4096(16의 세제곱) + 1 * 256(16의 두제곱) + 8 * 16 + 14 * 1(16의 0제곱) = 0x418E
* 16진수를 2진수로 : 16진수의 각 자리수를 (맨 앞자리를 제외하고는 반드시) 4자리 이진수로 변환해주면 됨
    - 4F38E = 100/1111/0011/1000/1110
* 2진수를 16진수로 : 2진수를 뒤에서부터 4자리를 끊어 읽으면 됨.
    - 4F38E 100/0001/1000/1110 : 0x418E

#### 메모리의 단위

* 휘발성 메모리 : 컴퓨터를 종료하면 데이터가 날아감, RAM(Random Access Memory)
* 비휘발성 메모리 : 데이터가 날아가지 않음, ROM(Read Only Memory)이나 하드디스크
* RAM는 데이터에 랜덤하게 접근할 수 있어서 속도가 빠름
* 이러한 특성 때문에 대부분 컴퓨터의 데이터는 메모리에 보관되어 있으며 틈틈히 중요한 데이터들은 하드 디스크에 저장함
* 컴퓨터의 한 개의 메모리 소자는 0 혹은 1 의 값을 보관할 수 있다. 이 이진수 한 자리를 가리켜 비트(Bit) 라고 부른다. 
* 1 개의 비트는 0 또는 1 의 값을 보관할 수 있다. 
* 너무나 작은 양이기에 8개의 비트를 묶어서 바이트(Byte) 라고 부른다. 8 비트 = 1 바이트
* 8 비트로 나타낼 수 있는 수, 다시말해 8 자리 이진수로 나타낼 수 있는 최대의 수
    - 00000000 ~ 11111111 = 0 ~ 255 = 0 ~ 0xFF

* 컴퓨터에서 연산을 담당하는 CPU의 메모리 공간인 레지스터(register), CPU에서 연산을 수행하기 위해 잠시 이곳에다가 값을 불러다 놓는다.
* 워드(Word) : 레지스터의 크기이자 컴퓨터 상에서 연산이 실행되는 최소 단위
* 32비트 컴퓨터의 경우 1 워드 = 32 비트 = 4 바이트, 64비트 컴퓨터의 경우 1 워드 = 64 비트 = 8 바이트

#### 정리

* 이진법은 0 과 1 로, 십진법은 0 부터 9로, 16진법은 0 부터 9, A, B, C, D, E, F 로 수를 표현. 
* 1비트는 이진수로 숫자 1 개를 의미하며, 1 바이트는 8 비트, 즉 이진수로 8 자리 수를 의미. 
* 1 바이트로 0 부터 255 까지의 수를 표현 가능. 컴퓨터에서 데이터를 잠시 기록해 놓는 것이 바로 메모리(RAM). 
* 보통의 컴퓨터의 경우 대부분 4 바이트 혹은 8 바이트 단위로 데이터를 처리.

---

### 3. 변수

* 컴퓨터가 기억하는 정보라는 것은 메모리에 전기 신호를 써놓는 것을 의미.
* 컴퓨터의 메모리인 RAM이라는 특별한 기억공간에 이를 기록.
* 철도처럼 직사각형이 붙어있는 형태로 표시, 각 방(사각형)에 1 바이트만큼의 데이터들을 저장 가능.
* 각방에 단순한 숫자로 이름을 붙임. 32 비트 CPU 기준 2^32(42억)개의 방을 가짐.
* 32비트 숫자를 매번 쓰는 대신 대개 16진법으로 주소값을 나타냄.
* 매번 16진수의 주소값을 사용하는 대신 변수에 주소값을 지정해서 변수를 호출해서 사용.
* 변수를 저장하면 컴퓨터는 알아서 메모리 어딘가에 해당 변수를 할당하고 내용을 저장.

```c
#include <stdio.h>
int main() {
  int a;
  a = 10;
  printf("a 의 값은 : %d \n", a);
  return 0;
}
```
* 변수 : 바뀔 수 있는 어떤 값을 보관하는 곳
* int : 변수의 자료형이 int(정수)형이라고 선언, -2147483648 에서 부터 2147483647 까지의 정수를 보관 가능
* %d : "" 다음에 처음으로 오는 변수(인자)를 10진수로 출력.
* %o : 인자의 값을 8진수로 출력
* %x : 인자의 값을 16진수로 출력

```c
#include <stdio.h>
int main() {
  float a = 3.141592f;
  double b = 3.141592;
  printf("a : %f \n", a);
  printf("b : %f \n", b);
  return 0;
}
```
* float : 실수형을 담을 수 있는 변수, double로 인식받지 않게 선언할 때 값 뒤에 f를 붙여야 한다.
* double : 실수형을 담을 수 있는 변수.
* %f : 실수형 변수를 출력하는 형식, 소수점 뒤의 값이 없더라도 소수점을 붙여야 한다.

```c
#include <stdio.h>
int main() {
  float a = 3.141592f;
  double b = 3.141592;
  int c = 123;
  printf("a : %.2f \n", a);
  printf("c : %5d \n", c);
  printf("b : %6.3f \n", b);
  return 0;
}
```
* %.(n)f : 소수점 n째 자리까지 무조건 표시.
* %(n)d : 자릿수를 n자리로 가능한한 표시.
* %(n).(N)f : 전체 자릿수는 n자리로 맞추되 반드시 소수점 N째 자리까지만 표시

#### C언어 변수 작명법

* 숫자는 중간이나 뒤에만 가능
* 영어, 숫자, _로만 구성
* 띄어쓰기 불가
* C 언어 예약어 불가

#### 정리

변수는 데이터를 임시로 저장하는 곳이며 자유롭게 쓰고 지울 수 있습니다.

각 변수에는 형(type) 이 있어서 해당 형에 맞는 데이터를 보관할 수 있습니다.

변수의 형으로는 정수값을 보관하는 char, int 등이 있고, 실수값을 보관하는 float 과 double 이 있습니다. 각각의 형들은 저장하는 데이터의 크기가 다릅니다.

int a = 10; 의 문장의 의미는 a 라는 정수형 변수를 정의한 뒤에, 해당 변수에 10 의 값을 대입한다 라는 뜻입니다.

변수의 이름을 정하기 위해서는 여러가지 규칙이 있습니다. 이 규칙에 알맞게 변수의 이름을 정해야 되며 그렇지 않을 경우 컴파일 오류가 발생합니다.

---

### 4. 연산자

#### 산술 연산자

* 사칙연산 가능
* /는 몫, %는 나머지를 의미

* 정수형 변수끼리 나누면 실제값이 실수라도 언제나 정수로 유지된다.
* 정수형 변수와 실수형 변수를 연산하면 실수형으로 출력 가능.
* 컴파일러의 산술 변환 : 자료형이 다른 두 변수를 연산 할 때 숫자의 범위가 큰 자료형으로 자료형이 바뀐다.


#### 대입 연산자

* 우측의 값을 좌측에 대입
* `a = a + 3` 같은 수학적으로 불가능한 식도 우측의 값을 먼저 계산하는 C언어에서는 가능.

```c
/* 대입 연산 */
#include <stdio.h>
int main() {
  int a = 1;

  printf("++a : %d \n", ++a);

  a = 1;
  printf("a++ : %d \n", a++);
  printf("a : %d \n", a);

  return 0;
}
```
* a++, ++a 는 각각 전위형, 후위형으로 미세한 차이가 있다.
* 전위형은 먼저 1을 더한 후 결과를 돌려주고, 후회형은 그 반대이다.

#### 비트 연산자

```c
/* 비트 연산 */
#include <stdio.h>
int main() {
  int a = 0xAF;  // 10101111
  int b = 0xB5;  // 10110101

  printf("%x \n", a & b);   // a & b = 10100101
  printf("%x \n", a | b);   // a | b =10111111
  printf("%x \n", a ^ b);   // a ^ b = 00011010
  printf("%x \n", ~a);      // ~a = 1....1 01010000
  printf("%x \n", a << 2);  // a << 2 = 1010111100
  printf("%x \n", b >> 3);  // b >> 3 = 00010110

  return 0;
}
```

* 비트 하나 하나에 대한 연산.
* 보통 8개의 비트를 묶어 1 바이트라 하고, 이진법으로 8자리 수, 십진법으로 0부터 255까지 나타날 수 있다.

* AND(&) 연산
    - 둘다 1이면 1, 하나라도 0이면 0으로 계산

* OR(|) 연산
    - 하나라도 1이면 1

* XOR(^) 연산
    - 두 수가 달라야만 1
   
* 반전 연산(~)
    - 0은 1로, 1은 0으로

* << 연산(쉬프트)
    - 왼쪽으로 비트를 쉬프트, 맨 앞의 숫자가 자리가 없으면 버려지고 새로 채워지는 숫자는 무조건 0

* >> 연산
    - 오른쪽으로 비트를 쉬프트, 숫자가 갈 자리가 없으면 앞부분에 맨 왼쪽에 있던 수를 복사

* int 형 변수는 하나의 데이터를 저장하기 위해 메모리 상의 4 바이트 (32비트)를 사용.
* 하나의 int 형 변수는 32자리의 이진수
    - int a = 1 == a = 00000000 00000000 00000000 00000001
    - int a = 0xAF == a = 10101111 == 00000000 00000000 00000000 10101111
        - 이를 반전시키면 11111111 11111111 11111111 01010000 == 0xFFFFFF50이 되는 것
    - <<와 >>도 똑같은 개념

#### 연산의 우선순위

* 1순위는 괄호
* 대부분 왼쪽 우선이지만 대입 연산자를 포함한 몇몇은 오른쪽 우선

#### 보수 표현법

* 변수의 타입에 따라 보관할 수 있는 데이터의 크기가 정해져 있다.

```c
#include <stdio.h>

int main() {
  int a = 2147483647;
  printf("a : %d \n", a);

  a++;
  printf("a : %d \n", a);

  return 0;
}
```

* 정수와 음수를 구분하는 방법
    - 1비트를 사용해서 부호를 나타낸다.
        - 첫번째 비트를 부호 비트로, 나머지는 실제 정수 데이터로 사용한다.
        - 0000과 1000을 모두 0으로 판단할 수 있는 문제가 생긴다.
    - 2의 보수 표현을 이용한다.
        - 컴퓨터가 4비트만 기억한다고 가정, x - x = 0이 나와야 함.
        - 이진수로 7인 0111에 더해 0000이 되는 이진수는 1001, 10000이 될 때 맨 앞의 1은 버려지기 때문
        - 이진수를 반전시킨 것에 1을 더하면 부호를 바꿀 수 있다.
        - 0000의 2의 보수는 그대로 0000이다.
        - int는 4바이트기에 최대 32비트, 32자리의 이진수까지 표현 가능, 십진법으로 나타내면 2,147,483,647까지 나타낼 수 있다. (unsigned 시 4294967295)
        - 맨 앞 비트를 부호 비트라고 생각하면 된다.
            - 음수나 양수의 덧셈 시 부호를 고려하지 않고 수행할 수 있다.
            - 맨 앞 비트를 사용해 부호를 빠르게 알아낼 수 있다.
    * 다시 위의 경우로 돌아가면 0x7FFFFFFF의 값을 1 증가시켜 0x800000000이 되고 이를 2의 보수 표현법으로 해석해 반전해서 1을 더하면 음수가 되버린다.
    * 오버플로우 : 자료형의 최대 범위보다 큰 수를 대입해 발생하는 문제

* unsigned int의 경우 0부터 4294967295까지의 수를 표현할 수 있다.
* unsigned int도 오버플로우가 발생할 수 있다. 음수 대신 0으로 돌아간다.

### 5. 문자 입력

* 0과 1밖에 처리하지 못하는 컴퓨터는 문자를 그대로 읽을 수 없기에 문자를 숫자에 대응시켜야 함.
* char : 1바이트 = 8비트, -128부터 127까지 숫자 표현 가능

```c
/* 문자를 저장하는 변수  */
#include <stdio.h>
int main() {
  char a;
  a = 'a';

  printf("a 의 값과 들어 있는 문자는? 값 : %d , 문자 : %c \n", a, a);
  return 0;
}
```

* 무조건 작은 따옴표로만 문자를 넣어야 함.
* 문자를 %d로 출력하면 해당 문자와 대응하는 유니코드가 출력됨.
* 유니코드의 전신인 아스키코드(ASCII, American Standard Code for Information Interchange)는 각각의 문자(알파벳)에 대응하는 번호를 붙인 것으로 0부터 127까지 총 128개(이후 1비트를 추가해서 256개)가 존재했음.
* 컴퓨터가 전세계로 보급되며 다양한 문자를 표현할 필요를 느끼자 유니코드(Unicode)라는 새로운 형식의 문자 체계를 도입. 한문자를 최대 4바이트(32비트)까지 처리. 

```c
/* 섭씨온도를 화씨로 바꾸기  */
#include <stdio.h>
int main() {
  double celsius;  // 섭씨 온도

  printf("섭씨 온도를 화씨 온도로 바꿔주는 프로그램 입니다. \n");
  printf("섭씨 온도를 입력해 주세요 : ");
  scanf_s("%lf", &celsius);  // 섭씨 온도를 입력 받는다.

  printf("섭씨 %f 도는 화씨로 %f 도 입니다 \n", celsius, 9 * celsius / 5 + 32);

  return 0;
}
```

* scanf : 화면(키보드)으로부터 결과를 받는 입력함수.
* printf 처럼 변수의 타입마다 입력받는 포맷을 달리 해야한다.
* printf와는 다르게 float는 %f로, double은 %lf로 입력받아야 한다.
* char : 최대 1바이트를 차지, 주로 문자를 저장하는데 사용, 한글은 2 바이트 이상을 차지하기에 한글을 넣으면 오류가 남.

```c
    //응용//
	int money;
	float money_USA = 1105.54;
	
	
	printf("얼마나 환전하시겠습니까?");
	scanf("%d", &money);

	printf("%d원을 환전한 금액은 %.2f 달러입니다.", money, money / money_USA);
	
	return 0;
```

---

### 6. 제어문 - 조건문

* 특정 조건에 따라 실행되는 문장.
* if문의 괄호 안 조건이 충족될 경우에만 중괄호 실행.
* `==` : 관계 연산자 중 하나, 좌변의 값과 우변의 값을 비교해 참이라면 1, 거짓이면 0을 반환한다.
* `if (0)` 일시 실행하지 않고 `if (1)` 일 때만 실행한다. 
* `>=`, `<=`는 가능하지만 `=<`, =>`는 불가능하다.
* `!=`는 좌우변의 값이 같지 않을 시 참을 반환한다.

* `else`는 앞선 if문의 조건을 만족하지 않을 때(참이 아닐때)의 경우를 처리한다.
* 그러므로 else는 단독으로 쓰일 수 없고 항상 앞에 if문이 존재해야만 한다.
* else문 안에서도 if를 쓸 수 있다.
* else if로 줄여서 쓸 수 있다.

* `&&` : 논리 연산자인 논리 곱(AND), 1 AND 1이여야만 (둘 다 참이여야만) 참이됨.
* `&`는 비트 사이의 AND 연산을 사용할 때 쓰이므로 조건식 사이에는 `&&`를 써야함.
* `&` : 정확한 비트 AND 연산 결과 / `&&` : 참(1) 혹은 거짓(0)

```c
if (height >= 180 && weight >= 90) {
}
```

* 다음 조건식에서 하나가 거짓임을 확인하면 다른 하나를 확인할 필요 없이 전체 연산 결과가 거짓임을 알 수 있다.
* SCE(Short Circuit Evaluation) : 한 조건식을 확인한 것만으로 전체 결과를 알 수 있는 경우 뒤의 조건을 확인하지 않는 컴퓨터의 방식.
* `&`연산의 경우 비트 하나하나를 대조하며 정확한 연산 결과를 제공해야 하지만 `&&`는 논리 결과에 따라 0이나 1만 돌려주면 되기에 SCE를 사용할 수 있다.

* `||` : 논리 연산자인 OR. 하나만 참이어도 참이다.
* `!` : 논리 연산자인 NOT. 값을 반전시킨다.

```
if (!p) {  // p == 0 과 같은 의미이지만 더 짧기 때문에 자주 사용된다 :)
  // p 가 0 일 때에만 실행된다.
}
```

* `!` 연산자는 0이 아닌 값은 0으로 변환시키기에 변수의 값이 0인지 아닌지 판별할 때 사용되기도 한다.

### 7. 반복문

* C언어 서적 : 열혈강의 C 프로그래밍, A Book On C, Teach Yourself C

```c
for (/* 초기식 */; /* 조건식 */; /* 증감식 */) {
  // 명령1;
  // 명령2;
  // ....
}
```

* 초기식 : for문(반복문)을 제어하기 위한 제어변수와 초기값을 지정한다.
* 조건식 : 제어 변수가 만족해야 할 조건을 지정한다. 조건식이 참일 때만 중괄호 속 명령을 실행한다.
* 증감식 : 실행 할 때 마다 변할 i의 값을 지정한다.
* for문의 조건문이 명시되지 않으면 항상 참이라고 인식한다. EX) `for (;;)`

* `break` : 해당 반복문을 무조건 탈출시킨다.
* `continue` : 해당 반복문의 조건부로 건너뛴다. 증감식은 그대로 적용된다.
* 한줄 if문은 중괄호가 필요없다.

```c
while (/* 조건식 */) {
  // 명령1;
  // 명령2;
  // ...
}
```

* `while`문은 조건식만 존재한다.
* 조건식이 참일 경우 계속 돌아간다.

```c
do {
  // 명령1;
  // 명령2;
  // ...
} while (/* 조건식 */);
```

* `do-while`은 `while`문과 거의 비슷하나 명령을 실행 후 조건식을 검사한다는 점에서 다르다.
* 최소한 한 번은 실행하게 된다.

#### 문제

```c
	// 문제 1 - 피라미드
	# include <stdio.h>
	int main()
{
	
	int i = 1;
	int n, j, star = 1;

	printf(" 삼각형의 줄은? : ");
	scanf("%d", &n);

	while (i <= n) {

		// 빈 공간을 넣을 반복문
		for (j = n - i; j >= 1; j--) {
			printf(" ");
		}

		// *을 찍을 반복문
		for (j = 1; j <= star; j++) {
			printf("*");
		}
		printf("\n");
		star += 2;
		i++;
	}

	return 0;
}

```

* 빈 공간과 `*` 공간을 어떻게 배치해야 하는지, 별은 어떻게 두 개씩 늘일지 막혔다.

```c
	// 문제 2 - 역피라미드
	# include <stdio.h>
	int main()
{
	int i;
	int n, j, star;

	printf(" 삼각형의 줄은? : ");
	scanf("%d", &n);

	star = n * 2 - 1;
	i = n; 

	while (i > 0) {

		// 빈 공간을 넣을 반복문
		for (j = n - i; j > 0; j--) {
			printf(" ");
		}

		// *을 찍을 반복문
		for (j = 1; j <= star; j++) {
			printf("*");
		}
		printf("\n");
		star -= 2;
		i--;
	}
	return 0;
}
	

```

* 문제 1의 코드에서 약간만 수정해 증감식을 빼는 것을 바꾸는 식으로 했다.

```c
	// 문제 3 - 배수의 합
	int number;
	int sum = 0;

	for (number = 0; number <= 1000; number++) {
		if (number % 3 == 0 || number % 5 == 0) {
			//printf("%d \n", number);
			sum += number;
		}
	}
	printf("자연수들의 합 : %d \n", sum);

	return 0;
```

*  큰 어려움 없었다. 논리 연산자의 사용방식이 살짝 헷갈렸다.

```c
	// 문제 4 - 피보나치
	int number;
	int even_sum = 0;
	int sequence_st = 1;
	int sequence_nd = 0;
	int term_sequence = 1;

	for (number = 1; number <= 1000000; number++) {
		
		if (number == sequence_st + sequence_nd) {
			term_sequence += 1;
			printf("피보나치 수열 제 %d 항: %d + %d = %d \n", term_sequence, sequence_st, sequence_nd, number);
			sequence_nd = sequence_st;
			sequence_st = number;
	
			
			if (term_sequence % 2 == 0) even_sum += number;


		}
	}
	printf("피보나치 수열의 짝수 항의 합 : %d \n", even_sum);

	return 0;
```

* for문을 사용했으나 다른 예제를 보면 while문을 사용하는 것이 더 효율적으로 보인다.

```c
	// 문제 5 - N의 곱

	int i, n, sum = 1;

	scanf("%d", &n);
	for (i = 1; i <= n; i++) sum *= i;

	printf("1부터 %d까지의 곱 : %d", n, sum);
	return 0;
```

* 큰 어려움 없었다.

```c
	// 문제 7 - 소인수 분해
	int n, i = 2, div_n;
	
	scanf("%d", &n);
	div_n = n;

	printf("N = %d \n", n);
	printf("%d = ", n);

	while (div_n >= i) {
		if (div_n % i == 0) {
			printf("%d ", i);
			div_n /= i;
			i = 2;

			if (div_n >= i) printf("* ");
		}

		else i++;

	}

	return 0;

```

* 큰 어려움 없었다. while문을 조금 더 매끄럽게 만들 수 있지 않을까 싶다.

### 8. 우분투 리눅스

### 9. switch문

```c
if (...) {
  ...
} else if (...) {
  ...
} else if (...) {
  ...
} else if (...) {
  ...
}

switch (/* 변수 */) {
  case /* 값1 */:
    // 명령들;
    break;
  case /* 값2 */:
    // 명령들;
    break;
    //.. (생략) ..
}
```

* if문이 여러 번 쓰일 경우 switch문을 쓰면 깔끔하게 정리할 수 있다.
* switch문에 사용될 변수(파라미터)는 반드시 정수 데이터를 보관하는 변수여야 한다.
* char, short, int, long 중 하나여야 한다.
* 문자도 컴퓨터는 숫자(유니 코드)로 변환해서 읽기에 문자도 정수에 해당된다. 
* 실수형 데이터를 보관하는 float나 double일 경우 오류가 발생한다.
* `변수 == 값`이 일치할 시 해당 case의 내용이 모두 실행된다. break로 switch문을 빠져나간다.
* 값에는 항상 상수만 배치되어야 한다. 변수가 오면 오류가 발생한다.
* default는 if의 else에 해당한다. 모든 case에 해당되지 않을 때 defalut가 실행된다.

#### 어째서 switch?

* if문은 각 if의 경우를 전부 계산한다. 모든 case에 대해 값을 비교하는 연산을 하게 된다.
* switch문은 내부적으로 jump table이란 것을 생성한다. jump table의 크기는 case의 값에 따라 달라진다. 
* switch문이 실행되기 전에 jump table이 작성되기에 값 부분에 변수가 들어가면 jump table을 알 수가 없게 된다.
* 각 값들은 case별로 명령들이 위치한 곳의 주소를 가리킨다. 
* switch문을 사용하면 case가 많아져도 성능에 지장이 생기지 않는다.

* switch 문이 효과적으로 처리되기 위해서는 case 의 '값' 들의 크기가 그다지 크지 않아야 하고, '값' 들이 순차적으로 정렬되어 있고, 그 '값' 끼리의 차이가 크지 않다면 최고로 효율적인 switch 문을 이용할 수 있게 된다.

---

### 10. 형변환

* 변수를 선언할 때 고유의 형을 부여함.
* 변수들이 메모리 상에 저장되는 특징이 다름.
* 형이 다른 변수 끼리 대입할 때 오류나 데이터의 손실이 생김.
* 이진수로 데이터를 표현하는 컴퓨터는 고정 소수점과 부동 소수점으로 실수를 표현한다.
* 고정 소수점 방식과 비교했을 때 같은 수의 비트만 사용해서 표현할 수 있는 수의 범위가 더 넓기 때문에 대부분의 컴퓨터는 부동 소수점 방식을 사용한다.
* 부동 소수점 방식을 통해 수를 표현하는 방법을 IEEE-754라고 부른다.
* 과학적 표기
	- 123,1234.123,−234 = 1.23×10^2,1.234123×10^-2, −2.34×10^2
* 컴퓨터가 소수를 표현하는 방법
	- ±f×b^e
	- f : 가수, b : 밑, e : 지수
	- 이진체계 상에서 b는 2로 고정
	- 소수 데이터를 보관할 때 f, e의 값만 저장하면 됨.
	- 부호 비트를 위해 1 비트가 더 필요 (0이면 양수, 1이면 음수)
	- `float`는 가수 부분이 23 비트, 지수 부분이 8 비트, 부호비트가 1 비트로 총 4 바이트를 차지(32 비트)
	- `double`은 가수 부분이 52 비트, 지수 부분이 11 비트로 총 8 바이트를 차지 (64 비트)

* 10010.1011 -> 십진법
	- 10010.1011(2) = 2^4 + 2^1 + 2^−1 + 2^−3 + 2^−4 = 18 + 0.5 + 0.125 + 0.0625 = 18.6875
* 모든 10진법으로 표현된 수를 2진법으로 바꿀 수는 없음.
* 무한히 나타나는 소수들을 일정부분 잘라서 보관하기에 오차 발생은 필연적임.

#### IEEE 754 방식으로 소수 저장

* 부호 비트에 0이나 1 할당
* 변환된 이진수를 정규화(어떠한 이진수를 1.xxxx꼴로 만드는 것)
	- -118.625 의 경우, 이진수 형태인 1110110.101 을 1.110110101 로 바꾸는 것. 
	- 가수 부분에는 xxxx 부분, 즉 110110101 만 저장
* 얼마나 쉬프트 연산을 하였는지 계산하여 지수 부분에는 얼마가 와야 하는지 알게 됨.
	- 1110110.101 을 1.110110101 로 바꾸었으므로 쉬프트 연산이 6번 오른쪽으로 일어남.
	- 지수에는 6 이 오게 됨
* 0.1 처럼 무한 소수의 수 경우 실수형 자료형에 할당된 비트에서 반올림을 함.
* 지수가 언제나 양수가 아니기에 계산한 지수에 바이어스 처리를 해줌.
	- 양수로 값을 넣는 것이 계산하기 편리하기에 정수 표현하듯 2의 보수표현법으로 지수를 고정하지 않음.
* 지수에 2^e-1 - 1 만큼을 더해줌. e의 값은 지수 부분의 비트 수. 
	- `float`일 경우 8인 127, `double`일 경우 11인 1023.
* `float`의 경우 지수에 들어가는 값의 범위가 1부터 254, `double`의 경우 1부터 2046.
	- `float`의 지수 부분은 2^-126부터 2^127까지 표현 가능.

* -118.625의 경우
	- 지수 부분에 6 + 127 = 133이 들어감.
	- 133은 이진수로 1000101
	- float a = 118.625의 메모리 구조는 https://modoocode.com/17 참조

#### 형 변환 (캐스팅)

* 형 변환(캐스팅)을 통해 변수의 자료형을 바꿀 수 있음.
* (바꾸려는 자료형) 변수 형태
* 해당 계산식에 한하여만 적용, 영구적이지 않음
* 변수 간의 나눗셈에서 하나라도 실수형 변수라면 소수점을 제대로 표현
* 정수형 변수간의 나눗셈이라면 몫만을 계싼

---

### 11. 배열, 상수

#### 배열

* 배열 : 특정한 형의 변수들의 집합
* `{}`를 사용해 값들을 둘러쌈.
* `(배열의 형) (배열의 이름)[원소 개수];`
	- int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
* 배열의 n번째 원소에 접근 - `arr[n-1]`로 인덱싱 (첫번째가 0으로 설정되었음)

* 배열은 메모리 상에서 서로 연속적으로 연결되어 있지만 arr[0]과 arr[9]의 뒤에는 다른 변수의 값들이 저장되어있음.
* 허락되지 않는 접근을 감지할 시 `Run-Time`오류를 발생.


### 배열

```c
#include <stdio.h>
int main()
{
	int arr[3] = {10, 20, 30};
	int* ptr = &arr;
	for (int i = 0; i < 3; i++)
	{
		printf("배열 arr[%d]의 값 : %d \n", i, arr[i]);
	}

	for (int i = 0; i < 3; i++)
	{
		printf("포인터 ptr[%d]의 값 : %d \n", i, ptr[i]);
	}

	ptr[0] = 100;
	ptr[1] = 200;

	for (int i = 0; i < 3; i++)
	{
		//printf("배열 arr[%d]의 값 : %d \n", i, arr[i]);
		printf("배열 arr[%d]의 값 : %d \n", i, *(arr + i));

	}

	for (int i = 0; i < 3; i++)
	{
		//printf("포인터 ptr[%d]의 값 : %d \n", i, ptr[i]);
		printf("포인터 ptr[%d]의 값 : %d \n", i, *(ptr + i));
		printf("포인터 ptr[%d]의 주소값 : %p \n", i, ptr + i);

	}
	// *(arr + i) == arr[i]
	// 배열의 주소 == 배열의 0번째(첫번째) 주소

	printf("arr 자체의 값 : %p\n", arr);
	printf("arr[0]의 주소 : %p\n", &arr[0]);

	printf("arr 자체의 값이 가지는 주소의 실제 값 : %d \n", *arr); // *(arr + 0)
	printf("arr[0]의 실제 값 : %d \n", arr[0]);


	// *&는 아무것도 것는 것과 같다. &는 주소, *은 주소의 값
	// *& 붙어있으면 서로 상쇄.

	return 0;
}
```

* 배열의 주소값을 포인터에 대입하니 `*`없이 포인터 변수 만으로도 인덱싱으로 원소의 값에 접근이 가능.
* 포인터로 대응하는 주소의 배열의 원소값에 `*` 없이 접근 및 수정이 가능.
* 포인터가 배열에 대응?
* 배열(arr)의 주소값과 값은 `배열[0]`의 주소값과 값과 똑같다.

#### SWAP
```c
#include <stdio.h>
void swap(int a, int b);
void swap_addr(int *a, int *b);
int main() {
	int a = 10;
	int b = 20;
	printf("a의 주소 : %p \n", &a);
	printf("b의 주소 : %p \n", &b);
	printf("SWAP 함수 전 -> a : %d, b : %d \n", a, b);
	swap(a, b);
	printf("SWAP 함수 후 -> a : %d, b : %d \n", a, b);

	printf("\n\n");
	// 값에 의한 복사 (Call by Value) -> 변수가 아닌 값만 복사, 지역함수 개념?

	// 메모리 공간의 주소값 자체를 넘기면?
	printf("a의 주소 : %p \n", &a);
	printf("b의 주소 : %p \n", &b);
	printf("SWAP_ADDR 함수 전 -> a : %d, b : %d \n", a, b);
	swap_addr(&a, &b);
	printf("SWAP_ADDR 함수 후 -> a : %d, b : %d \n", a, b);
	return 0;
}

void swap(int a, int b)
{
	printf("a의 주소 : %p \n", &a);
	printf("b의 주소 : %p \n", &b);
	int temp = a;
	a = b;
	b = temp;
	printf("SWAP 함수 내부 -> a : %d, b : %d \n", a, b);
}

void swap_addr(int *a, int *b)
{
	printf("a의 주소 : %p \n", &a);
	printf("b의 주소 : %p \n", &b);
	int temp = *a;
	*a = *b;
	*b = temp;
	printf("SWAP_ADDR 함수 내부 -> a : %d, b : %d \n", *a, *b);
}
```

* 함수에서 파라미터를 변경해도 아규먼트로 보낸 원래 변수의 값은 변하지 않는다.
* 파라미터를 포인터 변수로 지정하고 아규먼트 변수 앞에 &를 붙일 수 있다.
	- 함수 내부에서 값을 수정하면 원래 변수의 주소값에 해당하는 값을 변경하는 것이기에 함수 밖 변수도 영향을 받는다.

```c
# include <stdio.h>

void change_array(int* ptr);

int main() {
	int arr[3] = { 10, 20, 30 };
	//change_array(arr);
	change_array(&arr[0]);
	
	for (int i = 0; i < 3; i++) {
		printf("%d \n", arr[i]);
	}
}

void change_array(int* ptr)
{
	ptr[2] = 50;
}
```

* 배열은 변수 자체가 주소값(배열[0])을 가지기 때문에 *를 붙이지 않아도 연동이 된다.
* `change_array(arr) == change_array(&arr[0])`

```c

// 프로젝트

#include <stdio.h>
#include <time.h>


int level;
int arrayFish[6];
int* cursor;
void initData();
void printfFishes();
void decreaseWater(long preTime);
int checkFishAlive();

int main() {

	long startTime = 0; // 시작 시간
	long totalTime = 0; // 총 시간
	long preTime = 0; // 직전 경과 시간

	int num; // 몇 번 어항에 물을 줄건지 입력
	initData();


	cursor = arrayFish; // cursor[0] = arrayFish[0]

	startTime = clock(); // 현재 시간을 1000분의 1초 수준으로 반환

	printf("%d %d %d %d \n", cursor[0], cursor[1], cursor[2], cursor[3]);

	while (1)
	{
		printfFishes();
		printf(" 몇 번 어항에 물을 줄래?");
		scanf_s("%d", &num);


		// 입력값 체크
		if (num < 1 || num > 6)
		{
			printf("잘못 입력");
			continue;
		}

		// 총 경과 시간
		totalTime = (clock() - startTime) / CLOCKS_PER_SEC;
		printf("총 경과 시간 : %ld 초 \n", totalTime);

		// 직전 물 준 시간
		preTime = totalTime - preTime;
		printf("최근 경과 시간 : %ld 초 \n", preTime);

		// 어항의 물을 감소
		decreaseWater(preTime);

		// 입력한 어항에 물을 준다
			// 어항의 물이 없으면 줄 수 없다.
		if (cursor[num - 1] <= 0)
		{
			printf("%d번 어항은 이미 말라버렸다...\n",num);
		}
			// 물이 100 이하이다.
		else if (cursor[num - 1] + 5 >= 100)
		{
			printf("%d번 어항에 물이 넘칠 것 같다...\n", num);
		}
		else
		{
			printf("%d번 어항에 물을 준다. \n", num);
			cursor[num - 1] += 5;
		}


		// 레벨 업 여부
		if ((int)totalTime / 20 > level - 1)
		{
			level += 1;
			printf("레벨 업! \n");

			if (level == 6)
			{
				printf("게임 클리어! \n");
				exit(0);
			}
		}

		// 모든 물고기가 죽었는지 확인
		if (checkFishAlive() == 0)
		{
			printf("게임오버... \n");
			exit(0);
		}
		else {
			printf("화이팅!\n");

		}

		preTime = totalTime;

	}


	return 0;
}

void initData()
{
	level = 1; // 게임 레벨
	for (int i = 0; i < 6; i++)
	{
		arrayFish[i] = 100; // 물 높이
		//printf("물높이 : %d \n", arrayFish[i]);
	}
}

void printfFishes()
{
	for (int i = 0; i < 6; i++)
	{
		printf("%3d번 ", i + 1);
	}
	printf("\n");

	for (int i = 0; i < 6; i++)
	{
		printf(" %4d ", arrayFish[i]);
	}
	printf("\n\n");

}

void decreaseWater(long preTime)
{
	for (int i = 0; i < 6; i++)
	{
		arrayFish[i] -= (level * 3 * (int)preTime); // 줄어든 물의 양 처리
		if (arrayFish[i] < 0)
		{
			arrayFish[i] = 0;
		}
	}
}

int checkFishAlive()
{
	for (int i = 0; i < 6; i++)
	{
		if (arrayFish[i] > 0)
		{
			return 1;
		}
	}
	return 0;
}

```


##### 소수 찾는 프로그램
```c
#include <stdio.h>
int main() {
int arr[100]; // 소수를 저장할 배열
int guess = 4; // for문에서 돌릴 숫자
int i;
int max = 0;
int check = 1;
arr[0] = 2;

while (arr[99] < 0) {

	if (guess % 2 == 1)
	{
		for (i = max; i > -1; i--)
		{
			if (guess % arr[i] == 0) check = 0;
		}

		if (check == 1)
		{
			printf("%d는 소수입니다. ", guess);
			printf("%d번째 소수로 등록합니다. \n", max+2);
			arr[max + 1] = guess;
			max++;
		}

	}

	check = 1;
	guess++;
}


return 0;
}
```

* 배열의 원소의 수는 변수로 지정할 수 없다.
* C언어에는 배열의 크기를 변수를 통해 정의할 수 없다고 규정하고 있다.

#### 상수

* 상수는 처음 정의시 그 값이 바로 주어지고 영원히 바뀌지 않는다.
* `const (상수의 형) (상수 이름) = (상수의 값);`
* 상수 정의시 값을 지정해주지 않는다면 컴파일시 경고가 나온다.
* 상수의 값을 변경이 오류가 발생한다.

```c
#include <stdio.h>
int main() {
  int b = 3;
  const int a = b;
  char c[a];
  return 0;
}
```

* 상수로 배열의 크기를 할당할 수 있다. 
* 변수 b의 크기로 배열을 지정한 셈이 된다.

#### 초기화되지 않은 값

* 변수의 값을 초기화 하지 않아도 값이 0이 되지 않는다. 출력도 불가능하다.
* 마찬가지로 정의되지 않는 배열의 원소 또한 출력이 불가능하다.

```c
/* 초기화 되지 않은 값 */
#include <stdio.h>
int main() {
  int arr[3] = {1};
  printf("니 값은 모니 : %d", arr[1]);

  return 0;
}
```


* 첫번째 원소([0])에만 값을 넣어주어도 컴파일러는 자동으로 나머지 원소에 0을 넣어준다.
	- `int arr[3] = {1} == arr[0] = 1 == int arr[3] = {1, 0, 0}`

#### 고차원 배열

```c
// 위 경우 (배열의 형) 부분에 int 가 오면 된다. ? 에는 배열의 크기
(배열의 형) (배열의 이름)[?][?]; 
int arr[3][2];
```

* 배열의 배열을 만들 수 있다.
* 각 원소 3개가 원소를 2개 가지는 int형의 배열.
* arr[0]은 arr[0][0], arr[0][1]을 가지고 있다.
* 차원이 높아질 수록 활용도 또한 높아진다.

```c
/* 2 차원 배열 */
#include <stdio.h>
int main() {
  int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

  printf("arr 배열의 2 행 3 열의 수를 출력 : %d \n", arr[1][2]);
  printf("arr 배열의 1 행 2 열의 수를 출력 : %d \n", arr[0][1]);
  return 0;
}
```

* 2차원 배열 역시 1차원 배열처럼 메모리 상에서 연속적으로 존재한다.
* 2차원 배열의 경우 2차원 공간 안에서 행(줄)과 열로 이루어져 있다고 생각할 수 있다.

```c
int arr[2][3] = {1, 2, 3, 4, 5, 6};
int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
int arr[] = {1, 2, 3, 4};
```

* 모두 가능한 형태.
* 원소의 크기를 지정하지 않는 배열 선언은 불가능 ex) `int arr[];`

```c
int arr[][3] = {{4, 5, 6}, {7, 8, 9}}; // 가능
int arr[][2] = {{1, 2}, {3, 4}, {5, 6}, {7}}; // 가능
int arr[2][] = {{4, 5, 6}, {7, 8, 9}}; // 불가능
```

* C 다차원 배열에서는 맨 앞 크기를 제외한 나머지 크기들을 정확히 지정해줘야 한다.

#### 삼차원 배열

* `(배열의 형)(배열의 이름)[x][y][z];  // 여기서 x,y,z 는 배열의 크기를 말함.`
* 차원 배열이 늘어나도 n개의 값을 가지고 원소에 접근한다는 개념은 변함 없음.


### 다차원 배열

```c
int arr5[4][2];
	/* 
	 1 2
	1ㅁㅁ
	2ㅁㅁ
	3ㅁㅁ
	4ㅁㅁ

	[0,0][0,1]
	[1,0][1,1]
	[2,0][2,1]
	[3,0][3,1]
	
	*/

	int arr3[2][3][4];
	/*
	ㅁㅁㅁ ㅁㅁㅁ ㅁㅁㅁ ㅁㅁㅁ
	ㅁㅁㅁ ㅁㅁㅁ ㅁㅁㅁ ㅁㅁㅁ

	*/

	int arr_1[3][6] = { 
		{1,2,3,4,5},
		{3,4},
		{1} 
	};

	int arr_2[2][2][2] = {
		{
			{1, 2},
			{3, 4}
		},
		{
			{5, 6},
			{7}

		}
	};
```

* `getchar()` 사용자가 입력할 때까지 기다리는 함수.

```c
// 프로젝트

#include <stdio.h>
#include <time.h>

int arrayAnimal[4][5];
int ckeckAnimal[4][5];
char* strAnimal[10];

void initAnimalArray();
void initAnimalName();
void shuffleAnimal();
int getEmptyPostion();
int conv_pos_x(pos);
int conv_pos_y(pos);
void printAnimals();
void printQuestion();
int foundAllAnimals();
int main()
{
	srand(time(NULL));

	initAnimalArray();
	initAnimalName();
	shuffleAnimal();

	int failCount = 0;

	while (1) {
		int select1 = 0;
		int select2 = 0;

		printAnimals();
		printQuestion();
		printf("뒤집을 카드 2개 선택 : ");
		scanf_s("%d %d", &select1, &select2);

		if (select1 == select2) continue;

		int firstSelect_x = conv_pos_x(select1);
		int firstSelect_y = conv_pos_y(select1);

		int secondSelect_x = conv_pos_x(select2);
		int secondSelect_y = conv_pos_y(select2);

		if (ckeckAnimal[firstSelect_x][firstSelect_y] + ckeckAnimal[secondSelect_x][secondSelect_y] == 0
			&&
			arrayAnimal[firstSelect_x][firstSelect_y] == arrayAnimal[secondSelect_x][secondSelect_y])
		{
			printf("\n\n 빙고! : %s 발견 \n", strAnimal[arrayAnimal[firstSelect_x][firstSelect_y]]);
			ckeckAnimal[firstSelect_x][firstSelect_y] = 1;
			ckeckAnimal[secondSelect_x][secondSelect_y] = 1;
		}
		else if (ckeckAnimal[firstSelect_x][firstSelect_y] + ckeckAnimal[secondSelect_x][secondSelect_y] != 0)
		{
			printf("이미 뒤집힌 카드입니다. \n");
			failCount++;
		}

		else
		{
			printf("땡! \n");
			failCount++;
		}
		printf("%d : %s \n", select1, strAnimal[arrayAnimal[firstSelect_x][firstSelect_y]]);
		printf("%d : %s \n", select2, strAnimal[arrayAnimal[secondSelect_x][secondSelect_y]]);

	}

	if (foundAllAnimals())
	{
		printf("게임 클리어!");
		printf("총 %d 번 틀렸습니다.", failCount);
		exit(0);
	}

	return 0;
}


void initAnimalArray()
{
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 5; j++) {
			arrayAnimal[i][j] = -1;
		}
	}
}

void initAnimalName()
{
	strAnimal[0] = "원숭이";
	strAnimal[1] = "하마";
	strAnimal[2] = "강아지";
	strAnimal[3] = "고양지";
	strAnimal[4] = "돼지";
	strAnimal[5] = "코끼리";
	strAnimal[6] = "기린";
	strAnimal[7] = "낙타";
	strAnimal[8] = "타조";
	strAnimal[9] = "호랑이";

}

void shuffleAnimal()
{
	// ㅁㅁㅁㅁㅁ
	// ㅁㅁㅁㅁㅁ
	// ㅁㅁㅁㅁㅁ
	// ㅁㅁㅁㅁㅁ
	// ㅁㅁㅁㅁㅁ
	for (int i = 0; i < 10; i++) // 동물 짝 설정
	{
		for (int j = 0; j < 2; j++)
		{
			int pos = getEmptyPostion();
			int x = conv_pos_x(pos);
			int y = conv_pos_y(pos);

			arrayAnimal[x][y] = i;
		}
	}
}

// 빈 공간 찾기
int getEmptyPostion()
{
	while (1)
	{
		int randPos = rand() % 20; // 0 ~ 19 사이의 숫자를 반환
		int x = conv_pos_x(randPos);
		int y = conv_pos_y(randPos);

		if (arrayAnimal[x][y] == -1)
		{
			return randPos;
		}
	}
	return 0;
}

int conv_pos_x(pos)
{
	int x = pos / 5;
	return x;
}

int conv_pos_y(pos)
{
	int y = pos % 5;
	return y;
}


void printAnimals()
{
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 5; j++)
		{
			printf("%8s", strAnimal[arrayAnimal[i][j]]);
		}
		printf("\n");
	}
	printf(" \n ===============정답================\n");
}


void printQuestion()
{
	printf("\n\n 문제 \n\n");
	int seq = 0;

	/*								//seq				/checkAnimal
		ㅁㅁㅁㅁㅁ				0 1 2 3 4				0 0 0 0 0
		ㅁㅁㅁㅁㅁ				돼지 6 7 8 9 돼지			1 0 0 0 1
		ㅁㅁㅁㅁㅁ
		ㅁㅁㅁㅁㅁ
		ㅁㅁㅁㅁㅁ

	*/


	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 5; j++)
		{
			// 카드를 뒤집어서 정답을 맞추면 "동물 이름"
			if (ckeckAnimal[i][j] != 0)
			{
				printf("%8s", strAnimal[arrayAnimal[i][j]]);
			}

			// 아직 못 맞혔다면 숫자
			else
			{
				printf("%8d", seq);
			}
			seq++;

		}
		printf("\n");
	}
}

int foundAllAnimals()
{
	for (int i = 0; i < 4; i++)
	{
		for (int j = 0; j < 5; j++)
		{
			if (ckeckAnimal[i][j] == 0)
			{
				return 0;
			}
		}
	}
	return 1;
}

```

* int형 배열은 초기 선언 시 자동으로 모든 값을 0으로 초기화한다.

---

### 12. 포인터

* 모든 데이터들은 메모리 상 특정 공간에 저장되어 있다. 편의를 위해 이 특정 공간을 '방'이라고 칭한다.
* 각 방에는 데이터들이 들어간다.
* 한 방의 크기는 보통 1 바이트(8 비트)라고 정의된다. 4 바이트 짜리 int 형 변수를 정의하면 4개의 방을 차지하게 된다.
* 프로그램 작동 시 컴퓨터는 여러 방의 데이터를 필요로 하게 된다. 필요한 데이터를 구분하기 위해 각 방은 고유한 주소를 갖는다.
	- `int a = 123;` 이라고 정의하면 0x152839(16진수)라는 임의의 방의 시작 주소가 새겨진다.
	- 컴파일러가 `a = 10;`라는 문장을 받으면 0x152839 위치에서부터 4 바이트의 공간에 있는 데이터를 10으로 바꾸는 작업을 실행함.
* 32 비트 운영체제에서 작동되는 컴퓨터들의 주소값의 크기는 32 비트 (4 바이트)까지 나타남. (0x00000000 ~ 0xFFFFFFFF)
* 32 비트로 사용할 수 있는 주소값의 가짓수는 2의 32승 바이트, RAM은 최대 4GB까지 밖에 사용할 수 없음.

* 포인터도 `int`나 `char`같은 변수 중 하나.
* 포인터는 특정한 데이터가 저장된 주소값을 보관하는 변수이다.
* `포인터 : 메모리 상에 위치한 특정한 데이터의 (시작)주소값을 보관하는 변수`
* 포인터에는 형이 존재한다. `int`형 데이터와 `char`형 데이터의 주소값을 저장하는 포인터가 서로 다르다.
* `(포인터에 주소값이 저장되는 데이터의 형) *(포인터의 이름);`

```c
int* p;
```

* `p`라는 포인터가 int 데이터를 가리킨다.
* 포인터 `p`는 `int` 형 데이터의 주소값을 저장하는 변수가 된다

#### & 연산자

```c
a& b; //정상
a& //오류

&/* 주소값을 계산할 데이터 */
&a
```

* & 연산자를 통해 데이터를 주소값을 알 수 있다.
* &가 하나인 단항 연산자기에 AND 연산자(&&)와는 다르게 해석된다.
* 단항 & 연산자는 피연산자의 주소값을 불러온다.

```c
int a;
a = 2;

printf("%p \n", &a);
return 0;
```

* 출력할 때마다 값이 다르게 나온다.
* `%p`는 `&a`의 값을 16진수 형태로 출력한다. 
* 64비트 운영체제임에도 8 바이트(16진수로 16자리) 형태로 출력되지 않는다.
	- 앞의 0이 잘린 것 뿐. 정상.

```c
/* 포인터의 시작 */
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;

  printf("포인터 p 에 들어 있는 값 : %p \n", p);
  printf("int 변수 a 가 저장된 주소 : %p \n", &a);

  return 0;
}
```

* 한 번 정의된 변수의 주소값은 변하지 않는다.

#### * 연산자

```c
a * b; // a 와 b 를 곱한다.
a *; // 오류!
*a; // 단항 * 연산자
```

```c
/* * 연산자의 이용 */
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;
  a = 2;

  printf("a 의 값 : %d \n", a);
  printf("*p 의 값 : %d \n", *p);

  return 0;
}
```

* 포인터는 특정한 데이터의 주소값을 보관한다. 
* 포인터는 주소값을 보관하는 데이터의 형에 * 를 붙임으로써 정의된다.
* `&` 연산자로 특정한 데이터의 메모리 상의 주소값을 알아올 수 있다.
* `*` 연산자는 해당 주소값에 대응되는 데이터를 가져온다.
* `*` 연산자는 피연산자 두 개에 대해 작용할 때만 곱셈 연산자로 해석된다.
* `*`는 나(포인터)를 저장된 주소값에 해당하는 데이터로 간주하게끔 한다.
* `*p`를 통해 `p`에 저장된 주소(변수 `a`의 주소)에 해당하는 데이터, 즉 변수 `a`를 의미할 수 있게 된다.

```c
/* * 연산자 */
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;
  *p = 3;

  printf("a 의 값 : %d \n", a);
  printf("*p 의 값 : %d \n", *p);

  return 0;
}
```

* `p` 에 변수 `a` 의 주소를 집어 넣었다.
* `*p` 를 통해 "나에 저장된 주소(변수 a 의 주소)에 해당하는 데이터(변수 a) 로 생각하시오" 를 의미하게 되었다.
* `*p = 3` 은 `a = 3` 과 동일한 의미를 지니게 되었습니다.
* 포인터 `p`에 어떤 변수 `a`의 주소값이 저장되어 있다면 포인터 `p`는 변수 `a`를 가리킨다고 말한다.
* 포인터 또한 엄연한 변수 이므로 특정 메모리 공간을 차지한다.

#### 포인터에 타입이 있는 이유

```c
int a;
pointer *p;
p = &a;
*p = 4;
```

* `pointer`라는 타입이 있다고 가정.
* 포인터 `p`에는 명백히 변수 `a`의 주소값이 들어 있음.
* `a`에는 메모리에서 차지하는 모든 주소들의 위치가 아닌 시작 주소만 들어가 있다.
* `*p` 라고 했을 때 컴퓨터는 메모리에서 얼마만큼을 읽어들어야 할지 알 수 없다.
* 포인터에도 자료형을 지정해주어야만 어떤 데이터를 가리키는 지 알게 된다.
* `int *p`여야만 시작 주소로부터 정확히 4 바이트를 읽어 값을 바꿀 수 있다.

#### 포인터 = 변수

```c
p = &a;
*p = 2;
p = &b;
*p = 4;
```

* 포인터에 들어간 주소값이 바뀔 수 있다.

#### 정리

* 포인터는 주소값을 의미한다.
* 포인터는 메모리에 저장된 특정 데이터의 시작주소값을 저장한다. 이를 16진법으로 출력한다.
* 자료형 ex)`int` 뒤에 `*` 을 붙이면 포인터를 선언할 수 있다. ex) `int* p; or int *p;`
* & 연산자를 통해 변수에 해당하는 주소값을 포인터에 저장시킬 수 있다. 포인터에 주소값을 넣을 변수 앞에 사용한다. ex) p = &a;
* * 연산자를 통해 포인터를 포인터에 저장된 주소값에 해당되는 변수의 데이터로 취급할 수 있다. 포인터 앞에 사용한다. ex) *p = 3;

---

* 상수로 선언된 변수의 값은 절대로 변하지도, 변경하는 시도조차 할 수 없다.
	- 상수를 선언하면 실수로 변수의 값을 변경하는 사고를 원천봉쇄해준다.
	- 절대로 바뀌지 않을 값은 상수를 지정해주는 습관을 가지면 좋다.

```c
/* 상수 포인터? */
#include <stdio.h>
int main() {
  int a;
  int b;
  const int* pa = &a;

  *pa = 3;  // 올바르지 않은 문장
  pa = &b;  // 올바른 문장
  return 0;
}
```

* `const`는 이 데이터의 값이 절대로 바뀌면 안된다라고 일러주는 키워드다.
* `const int*`은 그 값을 절대로 바꾸면 안 되는 `int`형 변수를 가리킨다는 의미다.
	- `const int a`라는 변수는 값이 절대로 바뀌면 안되는 `int`형 변수 `a`를 가라킨다.
	- `a` 자체는 변수이므로 값이 자유롭게 변경될 수 있다.
* `const`가 붙은 `pa`가 가리키는 변수의 값을 절대로 바뀌면 안된다.
	- `pa`를 통해서 `a`를 간접적으로 가리킬 때는 값을 바꿀 수 없어진다.
	- 변수 `a` 자체가 `const`는 아니기에 `a = 3;`이라는 문장은 성립힌다.

```c
/* 상수 포인터? */
#include <stdio.h>
int main() {
  int a;
  int b;
  int* const pa = &a;

  *pa = 3;  // 올바른 문장
  pa = &b;  // 올바르지 않은 문장

  return 0;
}
```

* `int* const pa`는 `pa`의 값이 바뀌어선 안되다는 것을 의미한다.
	- 포인터에는 가리키는 데이터의 주소값이 들어간다.
	- `pa`가 `const`라는 것은 처음에 가리킨 `a`의 주소값 말고 다른 변수의 주소값은 절대로 들어갈 수가 없다는 뜻이다.
	- `pa`가 가리키는 값을 바꾸면 안되다는 말은 없었기에 `pa`를 통해 변수의 값을 바꾸는 것은 가능하다.

	```c
/* 전부 불가능 */
#include <stdio.h>
int main() {
  int a;
  int b;
  const int* const pa = &a;

  *pa = 3;  // 올바르지 않은 문장
  pa = &b;  // 올바르지 않은 문장

  return 0;
}
```

#### 포인터의 덧셈 뺄셈

```c
/* 포인터의 덧셈 */
#include <stdio.h>
int main() {
  int a;
  int* pa;
  pa = &a;

  printf("pa 의 값 : %p \n", pa);
  printf("(pa + 1) 의 값 : %p \n", pa + 1);

  return 0;
}
```

* `pa`에 들어간 변수의 주소값에 1을 더하면 해당 자료형의 크기 만큼이 더해진다.
	- `int` : 4 바이트
	- `char` : 1 바이트
	- `double` : 8 바이트
* 뺄셈도 같은 원리로 작동한다.
* 포인터끼리 더하는 것은 불가능하다.
	- 두 변수의 메모리 주소를 더하면 아무런 의미가 없는 값이 나온다.
* 포인터끼리 빼는 것은 가능하다.

#### 배열과 포인터

* 배열은 변수가 여러개 모인 것으로 생각할 수 있다.
* 배열들의 각 원소는 메모리 상에 연속으로 놓인다.
* 각각의 원소는 선언한 자료형의 크기에 따라 공간을 차지하게 된다.
	- int형 배열의 int형 원소는 4 바이트를 차지한다.
* 포인터는 자신이 가리키는 데이터의 형의 크기를 곱한 만큼 덧셈을 수행한다.
	- 포인터로도 배열의 원소에 접근이 가능하다.

```c
/* 과연? */
#include <stdio.h>
int main() {
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int* parr;
  int i;
  parr = &arr[0];

  for (i = 0; i < 10; i++) {
    printf("arr[%d] 의 주소값 : %p ", i, &arr[i]);
    printf("(parr + %d) 의 값 : %p ", i, (parr + i));

    if (&arr[i] == (parr + i)) {
      /* 만일 (parr + i) 가 성공적으로 arr[i] 를 가리킨다면 */
      printf(" --> 일치 \n");
    } else {
      printf("--> 불일치\n");
    }
  }
  return 0;
}
```

```c
/* 우왕 */
#include <stdio.h>
int main() {
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int* parr;

  parr = &arr[0];

  printf("arr[3] = %d , *(parr + 3) = %d \n", arr[3], *(parr + 3));
  return 0;
}
```

* parr + 3 을 수행하면 arr[3]의 주소값이 된다.
* `*`을 붙이면 * 연산자의 역할을 수행해 `*(parr + 3)`은  주소값에 해당하는 데이터인 arr[3]과 동일하게 된다.

```c
#include <stdio.h>
int main() {
  int arr[3] = {1, 2, 3};

  printf("arr 의 정체 : %p \n", arr);
  printf("arr[0] 의 주소값 : %p \n", &arr[0]);

  return 0;
}
```

* `arr`와 arr[0]의 주소값은 동일하다.
* 그러나 배열의 이름이 배열의 첫 번째 원소를 가리키는 포인터는 아니다.

```c
#include <stdio.h>
int main() {
  int arr[6] = {1, 2, 3, 4, 5, 6};
  int* parr = arr;

  printf("Sizeof(arr) : %d \n", sizeof(arr));
  printf("Sizeof(parr) : %d \n", sizeof(parr));
}
```

* `arr` 배열은 `int` 원소 6개를 썼으므로 크기가 24 바이트이다.
* `parr` 포인터는 포인터의 크기인 8 바이트를 나타난다.
* 배열의 이름과 첫 번째 원소의 주소값은 엄밀히 다른 것이다.
* C언어 상에서는 배열의 이름이 `sizeof`연산자나 주소값 연산자(`&')와 사용될 시 암묵적으로 첫 번째 원소를 가리키는 포인터로 타입 변환이 된다.

```c
/* [] 연산자 */
#include <stdio.h>
int main() {
  int arr[5] = {1, 2, 3, 4, 5};

  printf("a[3] : %d \n", arr[3]);
  printf("*(a+3) : %d \n", *(arr + 3));
  return 0;
}
```

* `[]` 연산자가 쓰이면 자동으로 형태를 바꾸어서 처리한다.
	- `arr[3]`은 `*(arr + 3)`으로 바뀌어서 처리된 것이다.
* `arr`는 `+` 연산자와 사용되기 때문에 첫 번째 원소를 가리키는 포인터 로 변환된다.
	- `arr + 3` 이 포인터 덧셈을 수행하여 배열의 4번째 주소값에 해당하는 데이터를 가리키게 된다.

```c
/* 신기한 [] 사용 */
#include <stdio.h>
int main() {
  int arr[5] = {1, 2, 3, 4, 5};

  printf("3[arr] : %d \n", 3 [arr]);
  printf("*(3+a) : %d \n", *(arr + 3));
  return 0;
}
```

* 자주 쓰이는 표현은 아니지만 `3[arr]`도 성립할 수 있다.
* `[]` 연산자가 `3[arr]`를 `*(3+arr)`로 바꿔주기에 `arr[3]`과 동일한 결과가 나온다.

#### 포인터의 정의

```c
int* p;
int *p;
```

* 포인터 변수를 여러 개 선언하기 용이하기에 `int *p`형식을 보통 더 많이 쓴다.
	- `int *a, *q, *r;

#### 문제
* `int arr[3][3];`같은 이차원 배열의 처리 방식
	- arr[i]는 i번째 행의 시작 주소값을 나타낸다.
	- `arr[3][3] == *(*(a+3)+3)`
* `int* arr[3];` : `int*` 변수 3개를 가지는 배열


#### 중간 정리

* 배열을 배열이고 포인터는 포인터이다.
	- sizeof 와 주소값 연산자와 함께 사용할 때를 제외하면, 배열의 이름은 첫 번째 원소를 가리킨다.
	- arr[i] 와 같은 문장은 사실 컴파일러에 의해 *(arr + i) 로 변환된다.
		- `printf ("%d", parr[1])` or `printf ("%d", arr[1])` == 
		`printf ("%d", *(arr + 1)` == 
		`printf ("%d", *(arr[0] + 1))`


#### 1차원 배열

```c
/* 포인터 이용하기 */
#include <stdio.h>
int main() {
  int arr[10] = {100, 98, 97, 95, 89, 76, 92, 96, 100, 99};

  int* parr = arr;
  int sum = 0;

  while (parr - arr <= 9) {
    sum += (*parr);
    parr++;
  }

  printf("내 시험 점수 평균 : %d \n", sum / 10);
  return 0;
}
```

* `arr`은 배열의 첫번째 원소를 가리키는 포인터로 자동 변환된다.
	- `parr = arr;`은 `parr = &arr[0]`와 동일하다.
	- `*` 없이도 주소값에 해당하는 값인 `arr[0]`에 접근할 수 있게 된다.
	- `printf ("%d", parr[1])` == `printf ("%d", *(arr + 1)` == `printf ("%d", *(arr[0] + 1))`
* 배열의 이름이 포인터로 타입 변경이 된다고 한들 
이는 단순히 출력 시 배열의 첫 번째 원소를 가리키는 주소값 자체가 될 뿐.

#### 포인터의 포인터

```c

/* 포인터의 포인터 */
#include <stdio.h>
int main() {
  int a;
  int *pa;
  int **ppa;

  pa = &a;
  ppa = &pa;

  a = 3;

  printf("a : %d // *pa : %d // **ppa : %d \n", a, *pa, **ppa);
  printf("&a : %p // pa : %p // *ppa : %p \n", &a, pa, *ppa);
  printf("&pa : %p // ppa : %p \n", &pa, ppa);

  return 0;
}

```

* `printf("&pa : %p // ppa : %p \n", &pa, ppa);`
	- `ppa`는 `int*`를 가리키는 포인터.
	- `pa`의 주소값이 들가간다.
	- `ppa == &pa;`
* `printf("&a : %p // pa : %p // *ppa : %p \n", &a, pa, *ppa);`
	- `pa`는 `a`를 가리키는 포인터.
	- `pa`에는 `a`의 주소값이 들어간다.
	- `&a` == `pa;`
	- `ppa`는 `pa` 를 가리키는 포인터.
	- `*ppa` 는 `pa`의 값을 지칭한다.
	- `pa`의 값인 `*a`를 출력한다.
* `printf("a : %d // *pa : %d // **ppa : %d \n", a, *pa, **ppa);`
	- `**ppa` == `*(*ppa)`
	- `*ppa`는 `a`를 주소값을 가리키는 `pa`의 값(`*pa`)을 가리킨다.



```c
#include <stdio.h>

int main() {
  int arr[3] = {1, 2, 3};
  int (*parr)[3] = &arr;

  printf("arr[1] : %d \n", arr[1]);
  printf("parr[1] : %d \n", (*parr)[1]);
}
```

* 배열 이름에 `sizeof` 연산자와 주소값 연산자를 사용할 때 빼고는 전부 포인터로 암묵적 변환이 이뤄진다.
	- 암묵적 변환은 주소값 연산자가 왔을 때에는 이뤄지지 않는다.
	- `&arr` != `int **`
* `arr`이 크기가 3인 배열이기 때문에 `&arr`을 보관할 포인터는 크기가 3인 배열을 가리키는 포인터로 정의해야 한다.
	- `int (*parr)[3] = &arr;`
	- 만일 `*parr`를 괄호로 감싸지 않으면 컴파일러가 `int*` 원소 3개를 가지는 배열을 정의한 것으로 간주한다.


* C 언어는 B 언어에서 파생된 언어
* B 언어에서는 실제 배열이 있고, 배열을 가리키는 포인터가 따로 있었다. 
* B 언어에서 arr 과 arr[0], arr[1] 은 각기 다른 메모리를 차지, arr 이 실제로 arr[0] 를 가리키는 포인터. 
* arr 의 값을 출력하면 실제로 arr[0] 의 주소값이, &arr 은 arr 의 주소값이 나왔다. 
* 따라서 B 언어에서 arr 과 &arr 은 다른 값을 출력했음.
* B 언의 문법을 계승한 C언어.
* 배열을 정의할 때 배열의 시작점을 가리키는 포인터로 공간을 낭비하는 것은 비효율적이라 판단.


```c
/* 정말로? */
#include <stdio.h>
int main() {
  int arr[2][3];

  printf("arr[0] : %p \n", arr[0]);
  printf("&arr[0][0] : %p \n", &arr[0][0]);

  printf("arr[1] : %p \n", arr[1]);
  printf("&arr[1][0] : %p \n", &arr[1][0]);

  return 0;
}
```

* `arr[0]` 의 값이 `arr[0][0]` 의 주소값과 동일. 
* `arr[1]` 의 값이 `arr[1][0]` 의 주소값과 동일. 
* 이차원 배열에서 `sizeof` 나 주소값 연산자와 사용되지 않을 경우, 
`arr[0]` 은 `arr[0][0]` 을 가리키는 포인터로 암묵적으로 타입 변환
* `arr[1]` 은 `arr[1][0]` 을 가리키는 포인터로 타입 변환된다라는 뜻.
	- `int arr[][]` 에서 `arr[0]` 과 `&arr[0][0]`는 같지 않음. 
	- 다만 암묵적으로 타입 변환 시에 같은 것으로 변할 뿐.


#### 포인터의 자료형

```c
/* 과연 될까? */
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int **parr;

  parr = arr;

  printf("arr[1][1] : %d \n", arr[1][1]);
  printf("parr[1][1] : %d \n", parr[1][1]);

  return 0;
}
```

* `int**`로 `arr`의 원소에 접근할 수 없다.

*  이차원 배열을 가리키는 포인터는 반드시 b 값(열의 개수)에 대한 정보를 포함하고 있어야 한다.
* 포인터 형은 다음과 같은 것에 의해 결정된다.
	- 가리키는 것에 대한 정보 (예를 들어, int* 이면 int 를 가리킨다, char** 이면 char* 을 가리킨다 등등)
	- 1 증가시 커지는 크기 (2 차원 배열에서는 b * (형의 크기) 를 의미한다 


```c
/* 1 증가하면 ? */
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};

  printf("arr : %p , arr + 1 : %p \n", arr, arr + 1);

  return 0;
}
```

```c
/* (배열의 형) */ (*/* (포인터 이름) */)[/* 2 차원 배열의 열 개수 */];
// 예를 들어서
int (*parr)[3];
```

* 이차원 배열에서 `a`가 1 증가하면 두 번째 행의 시작 주소값을 가리키는 포인터를 가리키게 된다.
* 2 차원 배열을 가리키는 포인터는 배열의 크기(이차원 배열의 열의 개수)에 관한 정보가 있어야 한다
* `int (*parr)[3];`는 크기가 3인 배열을 가리키는 포인터를 의미한다.

```c
/* 드디어! 배우는 배열의 포인터 */
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int(*parr)[3];  // 괄호를 꼭 붙이세요

  parr = arr;  // parr 이 arr 을 가리키게 한다.

  printf("parr[1][2] : %d , arr[1][2] : %d \n", parr[1][2], arr[1][2]);

  return 0;
}
```

* `int arr[a][b]`라고 정의된 2차원 배열.
	- `int arr[a][b]`은 `int arr[b]` 짜리 배열이 메모리에 `a` 개 존재하는 것
		- `arr[x][0]`의 주소값은 `x`번째 `int arr[b]`짜리 배열.
		- `arr[x][0]` == `arr+4b`
	- `arr[x][y]`의 시작 주소값은 `arr+4bx+4y`
* `arr[x][y]`의 주소값을 정확히 계산하기 위해서는 `b`(열의 개수)가 뭔지 알아야 한다.
*  2 차원 배열을 가리키는 포인터를 통해서 원소들을 정확히 접근하기 위해서는
	- 가리키는 원소(자료형)의 크기 (여기서 4)
	- b 의 값
* `/* (배열의 형) */ (*/* (포인터 이름) */)[/* 2 차원 배열의 열 개수 */];
// 예를 들어서
int (*parr)[3];`

```c
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int **parr;

  parr = arr;

  printf("parr[1][1] : %d \n", parr[1][1]);  // 버그!

  return 0;
}
```

* `int`를 가리키는 포인터 `int*`를 가리키는 `parr`.
	- 포인터인 ``int*`의 크기는 8 바이트. (64비트 기준)
* `parr[1][1]` == `*(*(parr + 1) + 1) == `*(((*parr)[3])+ 1)`
* `parr + 1`를 하면 주소값은 4가 아니라 8 증가함.
* `*(parr + 1) + 1`를 하면 `(parr+1)`의 타입인 `int*`의 크기에 맞춰 `int`의 크기만큼 4가 증가.
* *(parr + 1) + 1은 7이 되는 것.

#### 포인터 배열

```c
/* 포인터배열*/
#include <stdio.h>
int main() {
  int *arr[3];
  int a = 1, b = 2, c = 3;
  arr[0] = &a;
  arr[1] = &b;
  arr[2] = &c;

  printf("a : %d, *arr[0] : %d \n", a, *arr[0]);
  printf("b : %d, *arr[1] : %d \n", b, *arr[1]);
  printf("b : %d, *arr[2] : %d \n", c, *arr[2]);

  printf("&a : %p, arr[0] : %p \n", &a, arr[0]);
  return 0;
}
```

* 이제까지의 배열 포인터는 배열을 가리키는 포인터. 
	- 두 용어가 상당히 헷갈림. 언제나 진짜는 뒷부분 이라고 생각하면 됨. 
* 포인터 배열은 정말로 배열이고, 배열 포인터는 정말로 포인터.
* `int *arr[3];` == `int* arr[3];`
* 배열의 형을 `자료형*`로 하는 것도 가능.
* 배열의 각각의 원소가 int를 가리키는 포인터형으로 선언한 것.



### 배열 보충

#### 운영체제의 메모리 관리 방식

* C언어에서 사용된 변수들은 컴파일 시 기계어로 변경되어 메모리 주소로 바뀌어버린다.
	- 기계어에서는 변수 이름보다 메모리의 주소가 훨씬 중요하다.
	- 컴퓨터 시스테의 메모리는 운영체제가 관리하고 있다.
	- 운영 체제 (OS, Operating System) : 컴퓨터 시스템을 효과적으로 관리해는 소프트웨어, ex) 윈도우, 리눅스.

* C언어의 int형 개념은 운영체제의 비트 수와 일치, 32비트 운영체제에서는 int형이 32비트.
* 메모리는 1바이트 단위로 관리됨.
* 메모리를 사용하려면 메모리의 시작 주소와 한 번에 읽을 크기를 명시해야함.

* 직접 주소 지정 방식
	- C언어에서 변수에 값을 대입하면 어셈블리어 형태의 기계어로 번역된다.
	- 변수라는 개념으로 C언어는 직접 주소 지정 방식을 사용한다.
	- C언어에서 직접 주조 지정 방식은 서로 다른 함수에 존재하는 변수를 참조할 수 없다.
	- 함수를 호출하며 아규먼트를 보내야만 해당 함수에서 파라미터로 사용이 가능하다.
		- 아규먼트로 보낸 원본 변수의 값에 접근은 불가능하다.

* 간접 주소 지정 방식
	- 어떤 매개체를 이용해 주소를 간접적으로 명시한다.
	- 매개체는 4 바이트 크기의 메모리를 필요로 한다.
		- 32비트 운영체제가 주소를 32비트(4 바이트)로 저장하기 때문.
	- 값을 저장할 주소를 메모리에 저장.


#### 포인터

* 기존의 변수로는 다른 변수의 주소값을 읽거나 저장이 불가능, 이를 위한 문법이 포인터.
* 포인터 변수는 변수명 앞에 `*`를 붙이며 선언한다.
* 자료형이 무엇이든 포인터 변수의 크기는 4 바이트다. 자료형은 주소의 시작점에서 얼마나 읽어야 하는 지는 의미한다.

* 프로그램이 실행도리 때마다 사용할 메모리 공간의 주소는 매번 달라짐.
* 주소를 직접 입력하는 것보다 다른 변수의 주소값을 받는 것이 안전.
* 변수의 주소값은 변수 앞에 `&`를 사용하여 구할 수 있다.
* `*`는 두 가지 용도로 사용된다.
	- 포인터 변수 선언시.
	- `포인터 변수에 저장된 주소값이 가리키는 값`에 무언가를 대입할 시.

* 포인터 문법은 두 개의 메모리과 관련이 있다.
	- 포인터 변수가 저장된 메모리.
	- 포인터가 가리키는 대상 메모리.
* 포인터 변수도 변수처럼 자신이 저장된 메모리 공간을 가지고 있다.
	- 주소를 저장하기에 메모리 크기가 4 바이트로 고정된다.
	- 포인터 변수에 저장된 주소는 `포인터가 가리키는 주소값`의 시작점을 의미한다.
		- 실제 프로그램이 어떤 영역에 할당될지 모르기에 고정주소를 직접 표기해서 접근하는 것은 어렵다.
* 포인터에는 주소값이 저장되었기에 같은 함수가 아니더라도 주소값에 해당하는 값에 접근이 가능하다.

#### 포인터와 const 키워드

* 포인터 변수는 두 가지 형태로 `const` 키워드를 사용할 수 있다.
	- `const int *p` : 대상(주소값)을 상수화, 주소값에 해당하는 값 변경 불가능
	- `int *const p` : 자신을 상수화, 다른 주소값으로 변경 불가능
	- `const int * const p` : 대상과 자신 모두 상수화,  주소값에 해당하는 값 변경 불가능 및 다른 주소값으로 변경 불가능


#### 포인터 변수의 주소 연산

* 포인터는 시작주소와 사용할 크기로 메모리 범위를 기억.
* 사용할 크기는 선언할 때의 자료형의 크기와 동일.
* 포인터 변수 연산 시 기본 단위는 포인터 변수가 가리킬 주소(자료형)의 크기가 된다.
	- 자료형이 int형 일시 1 더할 때마다 4 (바이트) 씩 증가. 

#### 포인터와 대상의 크기

* `int *p`라고 선언 시 포인터 변수의 크기가 아닌 가리킬 대상의 크기를 의미하는 것. (포인터 변수의 크기는 항상 4 바이트로 고정.)
* 포인터 변수와 그 대상이 될 변수의 자료형을 같게 지정하는 것이 일반적.
* 의도적으로 다르게 사용하는 경우도 존재.

#### void *형 포인터

* `void *p;`
* 포인터 변수가 가리키는 대상의 크기가 정해지지 않음을 의미한다.
* 메모리의 시작 주소만 알고 끝 주소(얼마나 읽어야 할지) 모를 때 사용하는 포인터 형식이다.
* `void *p;`는 주소를 사용할 때 반드시 사용할 크기(형 변환)을 표기해야 한다.

```c
int data = 0;
void *p = &data;
*(int *)p = 5;
```

#### 배열 시작 주소

* 배열의 이름이 `sizeof` 연산자나 주소값 연산자(`&`)와 사용될 때 (예를 들어 `&arr`) 경우를 빼면,
배열의 이름을 사용시 암묵적으로 첫 번째 원소를 가리키는 포인터로 타입 변환된다.
* 배열 변수의 이름은 배열의 시작 주소이다.
* `char *p = &data[0]` == `char *p = & *(data + 0)` == `char *p = & * data` == `char *p = data` //???
	- `+0`은 생략 가능, `&`과 `*`는 서로 상쇄.
* 배열은 포인터처럼 다른 변수의 주소를 저장할 수 없다.
* 변수의 집합인 배열은 상수화된 주소이기에 자신이 위치한 메모리 주소, 시작 주소를 변경할 수 없다.

#### 배열과 포인터의 합체

* 포인터 변수도 배열로 선언해서 사용할 수가 있다.
* `char *p[2]` == `char *p1, *p2, *p3`
* 포인터 배열의 크기는 배열 개수 * 4 바이트
* 배열 기준으로 포인터와 합체 (포인터 배열)
	- `char *p[5]`시 [] 연산자가 더 우선이기에 p 변수는 5개의 항목을 가진 배열이 되고, 그 후에야 각 항목이 char *형 포인터라고 정해진다.\
	- 포인터 항목을 가진 배열인 p변수의 크기는 20 바이트이다.
* 포인터 기준으로 배열과 합체 (배열 포인터)
	-`char (*p)[5];`시 *가 더 우선이기에 p 변수는 포인터가 되고, 포인터 변수가 가리키는 주소값의 크기가 5 바이트라는 뜻이 된다.
	- p 변수의 크기는 4 바이트이다.
	- 가리키는 대상이 배열 형식(`char[5]`)이기에 []로 정확한 대상을 선택해야 한다.
	- 주소 연산 시 주소값의 크기가 5바이트이기에 5씩 증감한다.

#### 다차원 포인터

* 가리키는 대상의 개수만큼 차원이 증가.
	- 나의 친구에서 나는 친구를 가리키니 1차원, 친구는 대상 자체이니 0차원.
	- 나의 친구의 친구에서 나는 2차원, 나의 친구는 1차원
	- * 키워드가 하나씩 늘때마다 차원이 증가.

#### 2차원 포인터

* `*` 두개를 사용해서 선언.
* `**p` == `*(*p)`
	- `*p`가 가리키는 주소값에 해당하는 포인터의 값 == 해당 포인터가 가리키는 또다른 주소값
* 2차원 포인터가 가리키는 상자(주소값)의 값이 주소값이 아니라면 오류 발생.
	- 2차원 포인터는 1차원 포인터의 주소 값이 저장되어야 한다.

### 포인터 강의

```c
// `arr == &arr[0]`
// `*arr == arr[0]` `*(arr+2) == arr[2]`
// ptr + 1 == ptr + sizeof(*ptr)

int arr[2][3] = { {1,2,3}, {4,5,6} };

int(*ptr)[3] = &arr[0]; // 원소를 3개 가지는 1차원 배열을 가리키는 포인터
						// arr의 첫번째 행 전체를 가리키는 포인터
for (int i = 0; i < 2; i++)
{
	for (int j = 0; j < 3; j++)
	{
		printf("%d", ptr[i][j]);
	}
	printf("\n");
}

return 0;

```
* `arr[0]` 자체를 하나의 1차원 배열로 볼 수 있음.
* `arr[0]`은 원소(항목)들인 `arr[0][0], arr[0][1], arr[0][2]`을 의미한다.
* `(*ptr)[3]`는 원소를 3개 가지는 1차원 배열을 가리키는 포인터이다.
* `int(*ptr)[3] = &arr[0]`는 ptr이 3개의 원소를 가진 arr[0]이라는 배열 전체를 가리킨다고 볼 수 있다.
	-  *(ptr + i)에서 i가 하나 오를 때마다 주소값은 (포인터의 자료형 * 포인터가 가리키는 배열의 개수)만큼 증가한다.
	- i가 늘 때마다 arr의 다음 행을 가리킨다고 해도 무방.
* 2차원 배열의 한 행만큼을 가리키는 배열 포인터를 만들면 해당 배열을 치환하는 게 가능

* ptr[i] == arr[i]
* ptr[i][j] == arr[i][j]
* ptr == arr


```c
int arr[2][3] = { {1,2,3}, {4,5,6}};
for (int(*row)[3] = arr; row < arr + 2; row++)
{
	for (int* col = *row; col < *row + 3; col++)
	{
		printf("%d \n", *col);
		printf("%p \n", col);
		printf("%d \n", *row[0]);
		printf("%p \n", row[0]);
	}
	printf("\n");
}
```

* row는 세개짜리 int형 원소를 가진 배열을 가리키는 포인터, arr를 가리킨다.
* row에 1을 더하면 4 바이트 * 3인 12만큼 주소값이 증가한다.
* col은 row를 가리키는 포인터이다.
	- row는 row[0][0]로 표현할 수 있다.
	- row([0][0])는 arr[0][0]의 주소값과 동일한 주소값을 저장한다. 
	- col == *row == &(*row)[0]
	

---

### 13. 함수

* 함수를 선언하고 함수 호출 시 실행할 코드를 입력할 수 있다.
* `()`는 함수임을 의미한다.
* 함수의 이름은 한 눈에 알아 볼 수 있을 만큼 구체적으로 하면 좋다.
* 반환값이 없으면 선언 시 void, 있다면 해당 자료형으로 선언.
* `[함수 이름]();` 형식으로 호출한다. 함수가 파라미터를 받는다면 `()`안에 아규먼트를 기입한다.
* 함수는 반환되어 종료되거나 끝부분까지 실행하여 종료되거나 둘 중 하나다.
	- 반환하여 종료하는 것이 더 안전하다.
	- `return` 실행 시 함수는 무조건 종료되어 호출하였던 부분으로 돌아간다.
* 함수를 코드에 쓰게 되면 함수의 반환값이라는 의미를 가지게 된다.

#### main 함수

* 프로그램을 실행할 때 컴퓨터는 `main`함수부터 호출하면서 시작한다.
* 메인함수의 리턴 값은 운영체제가 받는다. (윈도우xp or 리눅스)
	- 정상적으로 종료되면 0, 비정상적으로 종료되면 1을 리턴한다.

```c
/* 마술 상자 */
#include <stdio.h>
int magicbox() {
  i += 4;
  return 0;
}
int main() {
  int i;
  printf("마술 상자에 집어넣을 값 : ");
  scanf("%d", &i);

  magicbox();
  printf("마술 상자를 지나면 : %d \n", i);
  return 0;
}
```

* main 밖의 함수는 main 함수 안에서 정의된 변수를 알지 못한다.
* 해당 변수에 대한 정보를 제공해야만 한다.

```c
/* 될까용 */
#include <stdio.h>
int slave(int my_money) {
  my_money += 10000;
  return my_money;
}
int main() {
  int my_money = 100000;
  printf("2009.12.12 재산 : $%d \n", slave(my_money));
  printf("my_money : %d", my_money);

  return 0;
}
```

* 함수를 선언할 때 필요로 하는 변수를 파라미터(매개변수)라는 형태로 `()` 안에 선언한다. 
* 함수를 호출 할 때 해당 파라미터에 대응하는 변수를 아규먼트(전달인자) 형태로 제공한다.
* 각 함수 내부에서 선언된 변수들은 같은 값이더라도 서로 다른 변수이고 메모리 상에서도 다른 위치를 점유하고 있다.

```
// 문제1
#include <stdio.h>

int magicbox(int num)
{
	return num + 4;
}

int main()
{
	int num;
	printf("input the number : ");
	scanf_s("%d", &num);
	// magicbox(num);
	num = magicbox(num);
	printf("sum : %d", num);

	return 0;
}
```

```c

//문제 2
#include <stdio.h>
int slave(int total_money, int earned_money)
{
	total_money += earned_money;
	return total_money;
}
int main()
{
	int total_money = 0;
	int earned_money;
	printf("input today income \n");
	while(1)
	{ 

	scanf_s("%d", &earned_money);
	if (earned_money == 0) break;
	total_money = slave(total_money, earned_money);
	printf("earned_money : %d \n total money : %d \n", earned_money, total_money);
	}
	return 0;
}
```

```c
#include <stdio.h>
// 문제 3
int sum_n(int n)
{
	int sum = 1;
	for (int i = 1; i <= n; i++)
	{
		sum *= i;
	}
	return sum;
}

int main()
{
	int n = 0;
	scanf_s("%d", &n);
	printf("sum = %d", sum_n(n));
	return 0;
}
```

```c

#include <stdio.h>
// 문제 4
int num_n(int n)
{
	int array[100] = {2, 3};
	int count = 2;
	int check = 1;
	for (int i = 4; i <= n; i++)
	{
		for (int j = 0; j < count; j++)	if (i % array[j] == 0) check = 0;

		if (check)
		{
			array[count] = i;
			count++;
		}
		check = 1;
	}

	for (int i = 0; i < count; i++) printf("소수 : %d \n", array[i]);

	return 0;
}

int main()
{
	int n = 0;
	scanf_s("%d", &n);
	num_n(n);
	return 0;
}
```

#### 함수와 포인터

*포인터는 특정한 변수의 메모리 상의 주소값을 저장하는 변수이다.
* int 형 변수의 주소값을 저장하면 int*, char 이면 char* 형태로 선언된다.
* `*` 단항 연산자를 이용하여, 자신이 가리키는 변수를 지칭할 수 있다.
* `&` 연산자를 이용하여 특정한 변수의 주소값을 알아낼 수 있다.

```c
/* 드디어 써먹는 포인터 */
#include <stdio.h>
int change_val(int *pi) {
  printf("----- chage_val 함수 안에서 -----\n");
  printf("pi 의 값 : %p \n", pi);
  printf("pi 가 가리키는 것의 값 : %d \n", *pi);

  *pi = 3;

  printf("----- change_val 함수 끝~~ -----\n");
  return 0;
}
int main() {
  int i = 0;

  printf("i 변수의 주소값 : %p \n", &i);
  printf("호출 이전 i 의 값 : %d \n", i);
  change_val(&i);
  printf("호출 이후 i 의 값 : %d \n", i);

  return 0;
}
```

* 포인터로 정의된 함수의 파라미터인 `*pi`에 `i`의 주소값을 인자로 전달.
* `pi`는 main함수의 `i`의 주소값(`i`)를 가리키게 된다.
* 어떤 함수가 특정한 타입의 변수/배열의 값을 바꾸려면 
함수의 인자는 반드시 그 타입을 가리키는 포인터를 이용해야 한다.

```c
/* 함수의 원형 */
#include <stdio.h>
int swap(int *a, int *b);  // 이 것이 바로 함수의 원형
int main() {
  int i, j;
  i = 3;
  j = 5;
  printf("SWAP 이전 : i : %d, j : %d \n", i, j);
  swap(&i, &j);
  printf("SWAP 이후 : i : %d, j : %d \n", i, j);

  return 0;
}
int swap(int *a, int *b) {
  int temp = *a;

  *a = *b;
  *b = temp;

  return 0;
}
```

* 함수의 원형 : 컴파일러에서 함수에 대한 정보를 제공한다.
* 소스 코드 제일 윗부분에 정의할 함수와 파라미터를 미리 적고 `;`를 붙여준다.
* 프로그래머의 실수를 사전에 예방해주는 역할을 한다. 반드시 지킬 것.

```c
#include <stdio.h>

int add_number(int* parr);

int main()
{
	int arr[3];
	int i;

	for (i = 0; i < 3; i++)
	{
		scanf_s("%d", &arr[i]);
	}

	add_number(arr);

	printf("배열의 각 원소 : %d %d %d", arr[0], arr[1], arr[2]);

	return 0;
}

int add_number(int* parr)
{
	int i;
	for (i = 0; i < 3; i++)
	{
		parr[i]++;
		// *(parr0+i)++;
	}
	return 0;
}
```

* 특정한 타입의 값을 변경하는 함수를 제작하려면, 
반드시 그 타입을 가리키는 포인터를 인자로 가져야 한다.
	- arr 이라는 배열을 가리키는 포인터가 바로 add_number 의 인자로 와야 한다.
	- int arr[3] 와 같은 일차원 배열을 가리키는 포인터는 바로 int* 형
	- arr 은 배열의 시작 주소 값을 가지고 있다. (`arr = &arr[0]`)
		- 즉 `parr`은 `arr` 배열의 시작 주소, `arr`을 가리키게 된다.
	- `parr[i]` == `*(parr+i)` == `*(parr[0] + i)` == `*&(parr + i)` == `*&(arr + i)`
	-  `char *p = &data[0]` == `char *p = & *(data + 0)` == 
	`char *p = & * data` == `char *p = data`

```c

/* 눈 돌아가는 예제. 포인터가 가리키는 변수를 서로 바꾼다.  */
#include <stdio.h>

int pswap(int** pa, int** pb);
int main() {
	int a, b;
	int* pa, * pb;

	pa = &a;
	pb = &b;

	printf("pa 가 가리키는 변수의 주소값 : %p \n", pa);
	printf("pa 의 주소값 : %p \n \n", &pa);
	printf("pb 가 가리키는 변수의 주소값 : %p \n", pb);
	printf("pb 의 주소값 : %p \n", &pb);

	printf(" ------------- 호출 -------------- \n");
	pswap(&pa, &pb);
	printf(" ------------- 호출끝 -------------- \n");

	printf("pa 가 가리키는 변수의 주소값 : %p \n", pa);
	printf("pa 의 주소값 : %p \n \n", &pa);
	printf("pb 가 가리키는 변수의 주소값 : %p \n", pb);
	printf("pb 의 주소값 : %p \n", &pb);
	return 0;
}
int pswap(int** ppa, int** ppb) {
	int* temp = *ppa;

	printf("ppa 가 가리키는 변수의 주소값 : %p \n", ppa);
	printf("ppb 가 가리키는 변수의 주소값 : %p \n", ppb);

	*ppa = *ppb;
	*ppb = temp;

	return 0;
}
```

* `int*` 타입을 가리키는 포인터의 타입은 `int**` 타입. 
* `ppa` 는 `pa` 를 가리키고 있고, `ppb` 는 `pb` 를 가리킨다.
* `int*` 형인 `pa` 의 값을 보관하는 변수는 반드시 `int*`형이여야만 한다.

```c
/* 2 차원 배열의 각 원소를 1 씩 증가시키는 함수 */
#include <stdio.h>
/* 열의 개수가 2 개인 이차원 배열과, 총 행의 수를 인자로 받는다. */
int add1_element(int (*arr)[2], int row);
int main() {
  int arr[3][2];
  int i, j;

  for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
      scanf("%d", &arr[i][j]);
    }
  }

  add1_element(arr, 3);

  for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
      printf("arr[%d][%d] : %d \n", i, j, arr[i][j]);
    }
  }
  return 0;
}
int add1_element(int (*arr)[2], int row) {
  int i, j;
  for (i = 0; i < row; i++) {
    for (j = 0; j < 2; j++) {
      arr[i][j]++;
    }
  }

  return 0;
}
```

* 두 개의 인자. 
	- 함수의 행의 수를 받는 인자.
	- 열의 개수가 2 개인 이차원 배열을 가리키는 포인터, 
* 함수의 인자에 한해서만 `int add1_element(int arr[][2], int row)`이 가능


```c
/* 상수를 인자로 받아들이기 */
#include <stdio.h>
int read_val(const int val);
int main() {
  int a;
  scanf("%d", &a);
  read_val(a);
  return 0;
}
int read_val(const int val) {
  val = 5;  // 허용되지 않는다.
  return 0;
}
```

* 상수의 값을 바꾸는 것은 불가능.

```c
/* 함수 포인터 */
#include <stdio.h>

int max(int a, int b);
int main() {
  int a, b;
  int (*pmax)(int, int);
  pmax = max;

  scanf("%d %d", &a, &b);
  printf("max(a,b) : %d \n", max(a, b));
  printf("pmax(a,b) : %d \n", pmax(a, b));

  return 0;
}
int max(int a, int b) {
  if (a > b)
    return a;
  else
    return b;

  return 0;
}
```

* 함수도 변수처럼 메모리 상에 저장되어 있다.
* 함수 포인터는 함수의 시작 주소를 가리킨다.
* 함수의 이름이 시작 주소값을 나타낸다.

* 함수 포인터 pmax 는 함수의 리턴값이 int 형이고, 인자 두 개가 각각 int 인 함수를 가리킨다.
* pmax 함수 포인터로 특정한 함수를 가리킬 때, 그 함수는 반드시 pmax 의 정의와 일치해야 한다. 
* `(함수의 리턴형) (*포인터 이름)(첫번째 인자 타입, 두번째 인자 타입,....)
// 만일 인자가 없다면 그냥 괄호 안을 비워두면 된다. 즉, int (*a)() 와 같이 하면 된다`
* 정의가 일치하면 max 함수의 시작 주소값을 pmax 에 대입할 수 있게 된다.
	- pmax = &max 와 같은 형식은 틀리다.

```c
// 문제 1

#include <stdio.h>


void input_score(int* grade);
void print_score(int* grade, int ave);
int main()
{
	int grade[5];
	int ave= 0;
	input_score(grade);

	for (int i = 0; i < 5; i++)
	{
		ave += grade[i];
	}
	ave /= 5;

	print_score(grade,ave);

	return 0;
}

void input_score(int* grade)
{
	for (int i = 0; i < 5; i++)
	{
		scanf_s("%d", &grade[i]);
		//printf("%d \n", grade[i]);
	}
}

void print_score(int* grade, int ave)
{
	int tmp;
	for (int i = 0; i < 5; i++)
	{
		for (int j = 0; j < 5; j++)
		{
			if (grade[i] > grade[j])
			{
				tmp = grade[i];
				grade[i] = grade[j];
				grade[j] = tmp;
			}
		}
	}
	for (int k = 0; k < 5; k++)
	{
		if (grade[k] >= ave) printf("합격 - ");
		else printf("불합격 - ");

		printf("%d \n", grade[k]);
	}
}

```


```c
// 토이 프로젝트


#include <stdio.h>
int add(int num1, int num2);
int sub(int num1, int num2);
int mul(int num1, int num2);
int div(int num1, int num2);
int input_num(int num);

int main_function() {
	int num1 = 0;
	int num2 = 0;
	int select = 0;
	printf("ㄴㅇㄹ");
	while (select < 5) {
		select = 0;
		num1 = input_num(num1);
		num2 = input_num(num2);
		printf("1. 더하기 \n 2. 빼기 \n 3. 곱하기 \n 4. 나누기 \n 5. 나가기\n 입력 :");
		scanf_s("%d", &select);
		switch (select)
		{
		case 1: 
		{
			printf("값 : %d", add(num1, num2)); 
			continue;
		}
		case 2: 
		{
			printf("값 : %d", sub(num1, num2)); 
			continue;
		}
			
		case 3: 
		{
			printf("값 : %d", mul(num1, num2)); 
			continue;
		}
			
		case 4: 
		{
			printf("값 : %d", div(num1, num2)); 
			continue;
		}
			
		default: 
		{
			printf("안녕히");
		}
		}

	}
	return 0;

}

int add(int num1, int num2)
{
	return num1 + num2;
}
int sub(int num1, int num2)
{
	return num1 - num2;
}
int mul(int num1, int num2)
{
	return num1 * num2;
}
int div(int num1, int num2)
{
	return num1 / num2;
}
int input_num(int num)
{
	printf("숫자를 입력하세요. \n");
	scanf_s("%d", &num);
	printf("\n 입력한 숫자 = %d \n", num);
	return num;
}

```

---

### 14. 디버깅

* `F10`으로 디버깅 창을 열 수 있다.
* `F10`을 누를 때 마다 한 줄 씩 코드를 실행한다.
* 조사식 항목에서 내가 보고 싶은 식을 검색할 수 있다. 

---

### 15. 문자열

```

* 컴퓨터는 문자열을 `char` 배열에 저장한다.
* 문자열의 마지막에는 끝을 의미하는 NULL 문자인 `\0`이 포함된다.
	- 문자 `0`이 아니다.
	- 마지막 공간에 자동으로 입력됨.
	- 문자열에 딱 맞게 배열을 설정하면 오류 발생.
* sizeof로 배열의 크기를 계산하면 문자열보다 1만큼 크게 나온다.
	- `\0`이 들어갈 자리가 필요.

```c
/* 널 뽀개기 */
#include <stdio.h>

int main() {
  char null_1 = '\0';  // 이 3 개는 모두 동일하다
  char null_2 = 0;
  char null_3 = (char)NULL;  // 모두 대문자로 써야 한다

  char not_null = '0';

  printf("NULL 의 정수(아스키)값 : %d, %d, %d \n", null_1, null_2, null_3);
  printf("'0' 의 정수(아스키)값 : %d \n", not_null);

  return 0;
}
```

```
/* 문자열의 시작 */
#include <stdio.h>
int main() {
  char sentence_1[4] = {'P', 's', 'i', '\0'};
  char sentence_2[4] = {'P', 's', 'i', 0};
  char sentence_3[4] = {'P', 's', 'i', (char)NULL};
  char sentence_4[4] = {"Psi"};

  printf("sentence_1 : %s \n", sentence_1);  // %s 를 통해서 문자열을 출력한다.
  printf("sentence_2 : %s \n", sentence_2);
  printf("sentence_3 : %s \n", sentence_3);
  printf("sentence_4 : %s \n", sentence_4);

  return 0;
}

```

* `\0` == 0 == `(char)NULL`
	- `0`과는 엄연히 다르다!
* 배열의 이름은 배열의 시작 주소를 가리킨다.
	- `%s`는 시작 주소에서부터 NULL이 나올 때까지 문자를 계속해서 출력해준다.
* 문자열(한 개 이상의 문자) 지정시 `""`를 사용한다.
* 한 개의 문자를 지정시 `''`를 사용한다.

* 영어는 글자당 1 바이트, 한글은 글자당 2 바이트.
* char 자료형의 크기는 1 바이트.

* char를 %d로 출력하면 아스키 코드가 출력됨.
	- 0과 1밖에 모르는 컴퓨터가 문자를 출력할 수 있는 이유.

* null은 아스키 코드로 0

```c
/* 문자열 바꾸기 */
#include <stdio.h>
int main() {
  char word[] = {"long sentence"};

  printf("조작 이전 : %s \n", word);

  word[0] = 'a';
  word[1] = 'b';
  word[2] = 'c';
  word[3] = 'd';

  printf("조작 이후 : %s \n", word);

  return 0;
}
```

* 문자열 선언 시 배열의 개수 지정을 생략할 수도 있다.


```c
/* 문자열 입력 */
#include <stdio.h>
int main() {
  char words[30];

  printf("30 자 이내의 문자열을 입력해주세요! : ");
  scanf("%s", words);

  printf("문자열 : %s \n", words);

  return 0;
}
```

* 문자열(배열)을 입력 받을 때는 `&`를 붙이지 않는다.
	- 배열의 이름 자체가 시작 주소를 포인팅하기 (가리키기) 때문이다.

#### scanf

```c
/* 이상한 scanf */
#include <stdio.h>
int main() {
  int num;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);
  return 0;
}
```

* 버퍼(buffer) : 컴퓨터가 문자를 입력받을 때 각 문자를 보관해놓았다가 한꺼번에 처리하는 방식.
* 키보드의 입력을 처리하는 버퍼는 `stdin`(입력 버퍼, 입력 스트림)이다.
* 키보드로 처리되는 모든 정보는 일시적으로 `stdin`에 저장되었다가 한꺼번에 처리된다.
* 개행 문자(엔터)`\n`를 입력 시 컴퓨터에 입력을 처리하라는 명령이 전달된다.
	- 1을 입력 시 컴퓨터에는 `1\n`이 저장된다.
* 입력 완료시 컴퓨터는 `scanf`를 함수를 이용해서 `stdin`으로부터 숫자를 받아온다.
	- ' '(띄어쓰기)_, '\n', '\t' 를 만날 때까지 데이터를 읽어온다.
	- 데이터를 읽어온 후 버퍼(`stdin`)에는 `\n`만이 남는다.
	- 다시금 `%c`를 사용한다면 버퍼에 남아 있던 `\n`가 대입된다. 
* `&c`는 이뮤불문 (가능하다면) 버퍼에 남아있는 한 개의 문자를 가져온다.
	- 버퍼에 `\n`이 남아 있는 채로 `%c`로 문자를 받아오면 `scanf`는 입력 받는 것을 생략하고 `\n`를 받아온다.
* `%s` 실행 시 실질 적인 데이터 (공백 문자가 아닌 것들) 이 나오기 전 까지 버퍼에 남아 있던 공백 문자들은 무시하고
실질 적인 문자(공백 문자가 아닌 것들)가 입력이 된다면 그 다음 부터 등장하게 되는 공백 문자에서는 종료하게 됩니다.
* `%s` 나 `%d` 그리고 다른 모든 수 데이터를 입력 받는 형식은 버퍼에 남아 있는 공백 문자에 신경쓰지 않고 사용할 수 있다.
	- 버퍼에는 개행 문자가 여전히 뒤에 남아있다.

```c
/* 마지막 stdin 예제 */
#include <stdio.h>
int main() {
  char str1[10], str2[10];

  printf("문자열을 입력하세요 : ");
  scanf("%s", str1);
  printf("입력한 문자열 : %s \n", str1);

  printf("문자열을 입력하세요 : ");
  scanf("%s", str2);
  printf("입력한 문자열 : %s \n", str2);

  return 0;
}
```

* 버퍼(`stdin`)에는 `hello babay\n`이 저장되어 있다. 
* `scanf`는 의미 있는 문자가 나올 때까지 공백 문자를 무시한다.
* str1 에는 hello 까지만 입력이 된다.
* 버퍼에는 ` baby\n`이 남는다.
* 두 번째 `scanf`를 거치며 남아있던  ` baby`를 곧바로 `str2`에 입력 받는다.
* 버퍼에는 `\n`이 남는다.

```c
/*

버퍼 비우기

주의하실 점은 반드시 MS 계열의 컴파일러로 컴파일 해주세요. 즉, Visual Studio
계열의 컴파일러로 말이죠. 이 말이 무슨 말인지 모르면 그냥 늘 하던대로 하면
됩니다.

gcc 에서는 정상적으로 작동되지 않는 위험한 코드 입니다.

*/
#include <stdio.h>
int main() {
  int num;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  fflush(stdin);

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);
  return 0;
}
```

* `fflush(stdin)`는 `stdin`을 완전히 지워준다.
	- 현재 vs에서는 작동하지 않는 코드다.

```c
/* getchar 함수 이용 */
#include <stdio.h>
int main() {
  int num;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  getchar();

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);

  return 0;
}
```

* `getchar`는 `stdin`에서 한 문자를 읽어와서 그 값을 리턴한다.
* 읽은 값은 지워진다.
	- `stdin`에 남아있는 `\n`을 읽어서 없앨 수 있다.
	- `getchar`를 두 번 쓰면 정상 작동한다.

```
/* c 에 무엇이 들어가는지 살짝 보아야 하므로 코드를 약간 수정했습니다 */
#include <stdio.h>
int main() {
  int num, i;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  getchar();

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);

  printf("입력한 문자 : %c", c);
  return 0;
}
```

* 버퍼에는 `123abc`이 저장되어 있다.
* `scanf`는 공백문자나 숫자가 아닌 것을 만날 때까지 버퍼에서 읽는다.
	- `123`까지 읽고 버퍼에서 읽는 것을 멈춘다.
* 버퍼에는 `abc\n`이 남아있다.
* `getchar`는 `a`를 읽어온다.
* 버퍼에는 `bc\n`이 남아있다.
* `scanf`는 버퍼에 남아있는 b를 c에 대입한다.

* 되도록 `%c`를 쓰지 않는 게 편하다.

```c
/* 문자열 */
#include <stdio.h>
int main() {
  char str[] = "sentence";
  char *pstr = "sentence";

  printf("str : %s \n", str);
  printf("pstr : %s \n", pstr);

  return 0;
}
```

* `pstr`은 포인터임에도 문자열의 값을 받았다.
* 문자열 "sentence"는 "sentence"라는 문자열이 저장된 주소값이다.
* 포인터 변수가 가리키는 문자열을 수정하려고 시도하면 에러가 난다.

#### 리터럴(literal)

```c
char *pstr = "goodbye";
printf("why so serious?");
scanf("%c", str[0]);
```

* 소스 코드 상에서 고정된 값을 일컫는 말이다.
* 큰 따옴표로 묶인 것들을 문자열 리터럴(string literal)이라고 부른다.
	- `goodbye`, `why so serious`, `%c` 모두 리터럴이 된다.
* 컴퓨터는 이러한 리터럴들을 따로 보관한다.
	- 프로그램을 실행하면 메모리 상의 특별한 곳(텍스트 세그먼트(text segment))에 생성된 리터럴들을 보관한다.
	- `char *pstr = "goodbye";` 실행 시 컴퓨터는 pstr에 "goodbye" 의 시작 주소값 좀 가져와서 대입하는 작업을 실행한다.
	- `pstr`은 "goodbye"의 리터럴을 가리키고 `printf("%s", pstr)` 했을 때 `goodbye`를 성공적으로 출력하게 된다.
* 리터럴은 고정된 값이기에 리터럴로 설정된 "goodbye" 문자열은 수정이 불가능하다.
	- 리터럴이 보관되는 곳은 오직 읽기만 가능한 곳이 된다.
		- 이곳을 함부로 변경하려고 하는 시도가 있다면 바로 프로그램이 강제로 종료되게 됩니다.
* `char str[] = "hello";`== `char str[] = {'h', 'e', 'l', 'l', 'o', '\0'};`
	- `str`배열에 "hello"라는 문자열을 복사할 뿐 리터럴은 아니다.
	- 배열은 텍스트 세그먼트가 아닌 스택이라는 수정이 가능한 영역에 정의가 된다.
*  VS 2017 이상에서는 리터럴을 char* 가 가리킬 수 없다.
반드시 const char* 가 가리켜야 하며, 덕분에 리터럴 수정을 컴파일 단에서 막을 수 있다. 

```c
int i, j = 0;
i = j + 3; // 가능
char str1[] = {"abc"};
char str2[] = {"def"};
str1 = str1 + str2; // 불가능
if (str1 == str2) // 불가능
```

* 배열의 이름은 메모리 상 저장된 배열의 첫번째([0]) 위치를 가리키는 포인터 상수이다.
* `str1 + str2`는 각 배열의 주소값을 더하게 된다.
	- 포인터 상수끼리 대입 연산을 시도하면 오류가 발생한다.
* `if (str1 == str2) `은 배열의 주소값을 비교하게 된다.
* `str1 = str2;`은 포인터 상수인 `str1`을 수정하게 된다.
	- 바뀔 수 없는 포인터 상수이기에 오류가 발생한다.
* 문자열을 다루기 위해서는 다음과 같은 함수가 필요하다.
	- 문자열 내의 총 문자의 수를 세는 함수

	- 문자열을 복사하는 함수

	- 문자열을 합치는 함수 (즉 더하는)

	- 문자열을 비교하는 함수

* 함수를 만들 때는 다음과 같은 사항을 고려해야 한다.
	- 함수가 하는 작업
	- 함수의 리턴형
	- 함수가 받을 인자

```c
/* copy_str 사용 예제 */
#include <stdio.h>
int copy_str(char *src, char *dest);
int main() {
  char str1[] = "hello";
  char str2[] = "hi";

  printf("복사 이전 : %s \n", str1);

  copy_str(str1, str2);

  printf("복사 이후 : %s \n ", str1);

  return 0;
}
int copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```

* `*src`가 `NULL`에 도달할 때까지 `while`문이 돌아간다.
* `*dest = *src`로 문자를 대입한다.
* 포인터에 1을 더하면 포인터가 가리키는 타입의 크기만큼 증가한다.
	- 배열의 다음 원소를 가리킨다.
* 마지막으로 `dest` 에 `\0` , 즉 `NULL` 문자를 집어 넣는다.

```c
#include <stdio.h>
int stradd(char *dest, char *src);
int main() {
  char str1[100] = "hello my name is ";
  char str2[] = "Psi";

  printf("합치기 이전 : %s \n", str1);

  stradd(str1, str2);

  printf("합친 이후 : %s \n", str1);

  return 0;
}
int stradd(char *dest, char *src) {
  /* dest 의 끝 부분을 찾는다.*/
  while (*dest) {
    dest++;
  }

  /*
  while 문을 지나고 나면 dest 는 dest 문자열의 NULL 문자를 가리키고 있게 된다.
  이제 src 의 문자열들을 dest 의 NULL 문자 있는 곳 부터 복사해넣는다.
  */
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  /* 마지막으로 dest 에 NULL 추가 (왜냐하면 src 에서 NULL 이 추가 되지
   * 않았으므로) */
  *dest = '\0';

  return 1;
}
```

* `dest`의 끝부분에서 널문자의 위치를 찾는다.
* `dest`의 끝에 `src` 문자열을 덧쓴다.
* 덧쓴 후 끝부분에 `NULL`문자를 집어 넣어야 한다.

```c
#include <stdio.h>
int compare(char *str1, char *str2);
int main() {
  char str[20] = "hello every1";
  char str2[20] = "hello everyone";
  char str3[20] = "hello every1 hi";
  char str4[20] = "hello every1";

  if (compare(str, str2)) {
    printf("%s 와 %s 는 같다 \n", str, str2);
  } else {
    printf("%s 와 %s 는 다르다 \n", str, str2);
  }

  if (compare(str, str3)) {
    printf("%s 와 %s 는 같다 \n", str, str3);
  } else {
    printf("%s 와 %s 는 다르다 \n", str, str3);
  }

  if (compare(str, str4)) {
    printf("%s 와 %s 는 같다 \n", str, str4);
  } else {
    printf("%s 와 %s 는 다르다 \n", str, str4);
  }

  return 0;
}
int compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```

* while 문에서 str1 의 끝에 도달할 때 까지 각 문자들을 비교한다. 
	- 한 문자라도 다르다면 if 문에 의해 0 이 리턴되고 함수는 종료된다.
	- str2 도 끝났는지 확인한다.


```c
// 문제 4


#include <stdio.h>

int find(char* dest, char* find);

int main()
{

	char str1[100] = "loman chi";
	char str2[10] = "hi";
	/*
	printf("문자열 1 입력");
	scanf("%s", str1);
	printf("문자열 2 입력");
	scanf("%s", str2);
	
	*/
	printf ("%d", find(str1, str2));
	return 0;
}

int find(char* dest, char* find)
{
	int location=0;
	while (*dest)
	{
		if (*dest == *find)
		{
			while (*find)
			{
				dest++;
				find++;
				if (*dest != *find) return -1;
			}
			return location;

		}
		dest++;
		location++;
	
	}
	return -1;
}


```

#### 책 관리 프로그램

* 프로그램을 만들 때는 다음을 고려해야 함.
	1. 프로그램이 할 작업
	2. 작업의 필요성 (필요 없으면 1로)
	3. 프로그램이 작동할 환경
	4. 개발할 언어

```c
#include <stdio.h>
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);

/* 책을 추가하는 함수*/
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {
  printf("추가할 책의 제목 : ");
  scanf("%s", book_name[*num_total_book]);

  printf("추가할 책의 저자 : ");
  scanf("%s", auth_name[*num_total_book]);

  printf("추가할 책의 출판사 : ");
  scanf("%s", publ_name[*num_total_book]);

  borrowed[*num_total_book] = 0; /* 빌려지지 않음*/
  printf("추가 완료! \n");
  (*num_total_book)++;

  return 0;
}
```

* 책 추가 함수
	- 배열의 이름이 배열의 메모리 상 시작 주소이기에 `&`를 붙이면 안된다.
	- `int` 형 변수의 경우 `int*` 포인터에 주소값을 전달하려면 `&`를 붙여야 한다.

```c
#include <stdio.h>
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book);

int compare(char *str1, char *str2);

/* 책을 검색하는 함수 */
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];

  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);

  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);

  printf("검색 결과 \n");

  if (user_input == 1) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(book_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 2) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 지은이 이름을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(auth_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 3) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 출판사를
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(publ_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  }

  return 0;
}
int compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```
* 책 검색 함수


```c
// 프로젝트

#include <stdio.h>
#include <time.h>

int main_array()
{
	srand(time(NULL));
	printf(" \n\n ======= 대머리 ====== \n\n");
	int answer;
	int treatment = rand() % 4; // 0 ~ 3 중 랜덤

	int cur_show = 0;
	int pre_show = 0;

	for (int i = 1; i <= 3; i++) {
		int bottle[4] = { 0, 0, 0, 0 };
			do {
				cur_show = (rand() % 2) + 2; // 2 or 3
			} while (cur_show == pre_show);

			pre_show = cur_show;
			int is_included = 0;
			printf(" > %d 번째 시도 : ", i);

			for (int j = 0; j < cur_show; j++)
			{
				int rand_bottle = rand() % 4; // 0 ~ 3

				if (bottle[rand_bottle] == 0) {
					bottle[rand_bottle] = 1;
					if (rand_bottle == treatment) is_included = 1;
				}
				else j--;
			}

			for (int k = 0; k < 4; k++)
			{
				if (bottle[k] == 1)	printf("%d ", k + 1);

			}
			printf(" 물약을 머리에 바릅니다. \n\n");
				if (is_included == 1) printf("자라나라 머리머리! \n");
				else printf("실패!  \n");
				printf("아무 키나 누르세요...");
				getchar();

			}


	printf("발모제는 몇 번?");
	scanf("%d", &answer);
	if (answer == treatment + 1) printf("정답!");
	else printf("오답! 답은 %d였습니다.", treatment + 1);



	return 0;

```

---

### 16. 구조체

```c
/* 구조체의 도입*/
#include <stdio.h>
struct Human {
  int age;    /* 나이 */
  int height; /* 키 */
  int weight; /* 몸무게 */
};            /* ; 붙이는 것 주의하세요 */
int main() {
  struct Human Psi;

  Psi.age = 99;
  Psi.height = 185;
  Psi.weight = 80;

  printf("Psi 에 대한 정보 \n");
  printf("나이   : %d \n", Psi.age);
  printf("키     : %d \n", Psi.height);
  printf("몸무게 : %d \n", Psi.weight);
  return 0;
}

struct 구조체이름 {
  멤버들..예를 들면 char str[10];
  int i;
}; /* 마지막에 꼭 ; 를 붙인다. */
```

* 구조체 : 제각각인 배열을 멤버로 가진다. 
* `struct [구조체] [구조체 변수 이름]`으로 구조체 변수를 지정할 수 있다.
* `Psi`의 타입은 `struct Human`, `Human 구조체`가 된다.
* `.`을 이용해서 구조체 변수의 멤버에 접근할 수 있다.
* 구조체를 정의할 때는 변수를 초기화 할 수 없다.

```c
/* 구조체 예제*/
#include <stdio.h>
struct Books {
  /* 책 이름 */
  char name[30];
  /* 저자 이름 */
  char auth[30];
  /* 출판사 이름 */
  char publ[30];
  /* 빌려 졌나요? */
  int borrowed;
};
int main() {
  struct Books book_list[3];
  int i;

  for (i = 0; i < 3; i++) {
    printf("책 %d 정보 입력 : ", i);
    scanf("%s%s%s", book_list[i].name, book_list[i].auth, book_list[i].publ);
    book_list[i].borrowed = 0;
  }

  for (i = 0; i < 3; i++) {
    printf("------------------------------- \n");
    printf("책 %s 의 정보\n", book_list[i].name);
    printf("저자 : %s \n", book_list[i].auth);
    printf("출판사 : %s \n", book_list[i].publ);

    if (book_list[i].borrowed == 0) {
      printf("안 빌려짐\n");
    } else {
      printf("빌려짐 \n");
    }
  }
  return 0;
}
```

* `int arr[3]`에서 `int`가 하나의 타입이듯 `struct Books`도 하나의 타입.
	- `book_list` 배열은 `struct Books`형의 변수가 3개 만들어지는 것.

#### 구조체 포인터

```c
/* 구조체 포인터 */
#include <stdio.h>
struct test {
	int a, b, c;
	char d;
};

int main() {
	struct test st;
	struct test* ptr;

	ptr = &st;

	(*ptr).a = 1;
	(*ptr).b = 3;
	(*ptr).c = 5;
	(*ptr).d = 'd';


	printf("st의 주소 : %p \n", ptr);
	printf("st의 주소 : %p \n", &st);
	printf("st의 값 : %d \n", *ptr);
	printf("st의 값 : %d \n", st);

	printf("st.a의 주소 : %p \n", &st.a);
	// printf("st.a의 주소 : %p \n", *ptr.a); // 불가능
	printf("st.b의 주소 : %p \n", &st.b);
	// printf("st.b의 주소 : %p \n", *ptr.b); // 불가능

	printf("st 의 a 멤버 : %d \n", st.a);
	printf("st 의 b 멤버 : %d \n", st.b);
	printf("st 의 c 멤버 : %d \n", (*ptr).c);
	printf("st 의 c 멤버 : %p \n", &(*ptr).c);
	printf("st 의 d 멤버 : %c \n", (*ptr).d);
	printf("st 의 d 멤버 : %p \n", &(*ptr).d);
	return 0;
}
```

* ! 구조체도 배열처럼 구조체 변수의 이름이 첫번째 멤버의 주소값을 나타낸다.

* 구조체 포인터로 가리키는 주소에 해당하는 구조체에 접근이 가능하다.
* 구조체 (`struct test`)도 하나의 형(타입).
	- `struct test *ptr`는 `struct test` 형을 가리키는 포인터 `ptr`을 정의한 것
	- 구조체 `st`를 가리키는 `ptr`은 구조체가 아닌 4 바이트를 차지하는 포인터이다.
* 배열과는 달리 포인터에 주소값을 할당할 때 `&`를 붙여서 할당한다.
	- 구조체 변수는 배열이 아닌 보통의 변수이다.
* `(*ptr).a` == `st.a`
	- 괄호 없이 `*ptr.a = 1`라고 쓰면 오류가 발생한다.
		- 연산자 순위에 따라 `.`이 `*`보다 우선순위이기 때문.
		- `*ptr.a` == `*(ptr.a)`
		- `ptr`은 멤버를 가지고 있는 구조체가 아닌 포인터기에 오류가 발생.

```c
/* 구조체 포인터 */
#include <stdio.h>
struct test {
  int a, b;
};
int main() {
  struct test st;
  struct test *ptr;
  ptr = &st;
  ptr->a = 1;
  ptr->b = 2;
  printf("st 의 a 멤버 : %d \n", st.a);
  printf("st 의 b 멤버 : %d \n", st.b);
  return 0;
}
```

* `->`를 사용하면 보다 간편하게 포인터로 구조체의 멤버에 접근할 수 있다.
	- `->`는 `.`처럼 우선순위 1순위이다.

```c
/* 헷갈림 */
#include <stdio.h>
struct TEST {
  int c;
  int *pointer;
};
int main() {
  struct TEST t;
  struct TEST *pt = &t;
  int i = 0;

  /* t 의 멤버 pointer 는 i 를 가리키게 된다*/
  t.pointer = &i;

  /* t 의 멤버 pointer 가 가리키는 변수의 값을 3 으로 만든다*/
  *t.pointer = 3;

  printf("i : %d \n", i);

  /*

  -> 가 * 보다 우선순위가 높으므로 먼저 해석하게 된다.
  즉,
  (pt 가 가리키는 구조체 변수의 pointer 멤버) 가 가리키는 변수의 값을 4 로
  바꾼다. 라는 뜻이다/

  */
  *pt->pointer = 4;

  printf("i : %d \n", i);
  return 0;
}
```

* 구조체 변수 `t`의 `pointer`라는 멤버에는 `i`의 주소값이 들어간다.
	- `t.pointer`는 `i`를 가리킨다.
* `*t.pointer = 3;`
	- `.`이 `*`보다 우선순위
	- `t.pointer`가 먼저 해석되고 `*(t.pointer)` 형태로 해석하게 된다.
	- 구조체 변수 `t`의 `pointer` 멤버가 가리키는 `i` 변수에 접근 할 수 있게 된다.
* `*pt->pointer = 4;`
	- `->`이 `*`보다 우선순위
	- `pt->pointer`가 먼저 해석되고 `*(pt->pointer)` 형태로 해석되게 된다.
		- `*(pt->pointer)` == `*pt->pointer`
	- 구조체 변수 `t`를 가리키는 포인터 `pt`로 
	구조체 변수 `t`의 `pointer` 멤버가 가리키는 `i` 변수에 접근 할 수 있게 된다.

```c
/*

구조체 포인터 연습

 */
#include <stdio.h>
int add_one(int *a);
struct TEST {
  int c;
};
int main() {
  struct TEST t;
  struct TEST *pt = &t;

  /* pt 가 가리키는 구조체 변수의 c 멤버의 값을 0 으로 한다*/
  pt->c = 0;

  /*
  add_one 함수의 인자에 t 구조체 변수의 멤버 c 의 주소값을
  전달하고 있다.
  */
  add_one(&t.c);

  printf("t.c : %d \n", t.c);

  /*
  add_one 함수의 인자에 pt 가 가리키는 구조체 변수의 멤버 c
  의 주소값을 전달하고 있다.

  */
  add_one(&pt->c);

  printf("t.c : %d \n", t.c);

  return 0;
}
int add_one(int *a) {
  *a += 1;
  return 0;
}
```

* `add_one(&t.c)` == `&(t.c)`

#### 구조체의 대입

```c
#include <stdio.h>
struct TEST {
  int i;
  char c;
};
int main() {
  struct TEST st, st2;

  st.i = 1;
  st.c = 'c';

  st2 = st;

  printf("st2.i : %d \n", st2.i);
  printf("st2.c : %c \n", st2.c);

  return 0;
}
```

```c
#include <stdio.h>
char copy_str(char *dest, char *src);
struct TEST {
  int i;
  char str[20];
};
int main() {
  struct TEST a, b;

  b.i = 3;
  copy_str(b.str, "hello, world");

  a = b;

  printf("a.str : %s \n", a.str);
  printf("a.i : %d \n", a.i);

  return 0;
}
char copy_str(char *dest, char *src) {
  while (*src) {
  		// printf("%c \n", *src);
		// printf("%p \n", src);
		// printf("%p \n", dest);
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```

* 같은 구조체에서 탄생한 구조체 변수끼리는 대입을 할 수 있다.
* `a = b`
	- `b` 구조체의 모든 멤버의 데이터가 `a` 구조체에 일대일로 대응이 된다.

#### 구조체를 인자로 전달

```c
/*구조체를 인자로 전달하기 */
#include <stdio.h>
struct TEST {
  int age;
  int gender;
};
int set_human(struct TEST a, int age, int gender);
int main() {
  struct TEST human;
  set_human(human, 10, 1);
  printf("AGE : %d // Gender : %d ", human.age, human.gender);
  return 0;
}
int set_human(struct TEST a, int age, int gender) {
  a.age = age;
  a.gender = gender;
  return 0;
}
```

* 특정한 변수의 값을 다른 함수를 통해 바꾸려면 변수의 주소값을 전달해야 한다.
	- `a.age = age;`를 했을 때 아규먼트로 보낸 `human`이라는 구조체 변수의 멤버의 값이 변하는 게 아닌
	`set_human` 함수의 `a`라는 별개의 구조체 변수의 멤버의 값이 바뀌는 것.
* 실제 `human` 구조체 변수의 멤버는 전혀 초기화되지 않았다.

```c

#include <stdio.h>
struct TEST {
	int age;
	int gender;
	char name[20];
};
int set_human(struct TEST *a, int old, int sex, const char *name);
char copy_str(char* dest, const char* src);
int main() {
	struct TEST human;
	struct TEST* pt = &human;

	set_human(pt, 10, 1, "Lee");
	printf("AGE : %d // Gender : %d // Name : %s \n", pt->age, pt->gender, pt->name);
	return 0;
}
int set_human(struct TEST *a, int old, int sex, const char *name) {
	a->age = old;
	a->gender = sex;
	copy_str(a->name, name);
	
	return 0;
}

char copy_str(char* dest, const char* src)
{
	while (*src) {
		*dest = *src;
		src++;
		dest++;
	}

	*dest = '\0';

	return 1;

}

```

* `set_human` 함수는 구조체의 포인터를 인자로 취하고 있다.
* `set_human`를 호출할 때도 `&`로 `human`의 주소값을 인자로 전달한다.
* `a`는 구조체 변수 `human`을 가리킨다.
	- `a`는 구조체 변수가 아닌 포인터이다. 단순히 `human` 구조체 변수가 메모리 상 위치한 곳의
	시작점의 주소값을 보관할 뿐이다.
* `a->age` != `age`
	- `a->age`는 human 구조체 변수의 `int`형 멤버 `age`를 가리킨다.
	- `age`는 `set_human` 함수에서 인자로 받은 `int`형 `age`변수를 가리킨다.
* `copy_str(a->name, name);`
	- `a->name`으로 `human` 구조체 변수의 `name` (배열)멤버의 주소값을 전달한다.
	- `name`으로 함수를 호출할 때 받은 문자열의 주소값을 전달한다.

#### 구조체 안의 구조체

```c
/* 구조체 안의 구조체*/
#include <stdio.h>
struct employee {
  int age;
  int salary;
};
struct company {
  struct employee data;
  char name[10];
};
int main() {
  struct company Kim;

  Kim.data.age = 31;
  Kim.data.salary = 3000000;

  printf("Kim's age : %d \n", Kim.data.age);
  printf("Kim's salary : %d$/year \n", Kim.data.salary);

  return 0;
}
```

* 구조체도 형(type)의 일종이기에 구조체의 구조체를 정의하는 것도 가능하다.
* `struct employee`라는 형의 구조체 변수인 `data`를 선언한 것이다.
* `Kim.data.age`
	- 구조체의 구조체도 `.`으로 접근한다.
	- `.` 연산자의 우선 순위는 왼쪽이므로 `(Kim.data).age`가 먼저 해석된다.
		- `Kim 의 data 멤버의 age 멤버`

#### 구조체 리턴

```c
/* 구조체를 리턴하는 함수 */
#include <stdio.h>
struct AA function(int j);
struct AA {
  int i;
};

int main() {
  struct AA a;

  a = function(10);
  printf("a.i : %d \n", a.i);

  return 0;
}

struct AA function(int j) {
  struct AA A;
  A.i = j;

  return A;
}
```

* `int`형 멤버 `i` 를 가진 `AA` 구조체 정의.
* `function`은 `struct AA` 형을 리턴하는 함수다. 인자는 `int j`를 가진다
	- `struct AA` 형을 리턴하기에 리턴값도 `struct AA`형이 되어야 한다.
	- `j` 값으로 `A`의 `i`멤버를 `j`의 값으로 초기화 한 후 이를 그대로 리턴한다.
*  `function(10);`을 통해 리턴한 `struct AA`타입의 구조체 변수 `A`를 
`main`에서 정의한 `struct AA` 타입의 구조체 변수 `a`에 대입한다.

```c
/*

구조체 변수를 정의하는 색다른 방법.
예제를 이렇게 길게 만든 이유는 소스를 읽으면서 구조체와 조금 더 친해지기 바래서
입니다. 소스를 찬찬히 분석해보세요 ^^

*/
#include <stdio.h>
char copy_str(char *dest, char *src);
int Print_Obj_Status(struct obj OBJ);
struct obj {
  char name[20];
  int x, y;
} Ball;

int main() {
  Ball.x = 3;
  Ball.y = 4;
  copy_str(Ball.name, "RED BALL");

  Print_Obj_Status(Ball);

  return 0;
}
int Print_Obj_Status(struct obj OBJ) {
  printf("Location of %s \n", OBJ.name);
  printf("( %d , %d ) \n", OBJ.x, OBJ.y);

  return 0;
}
char copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```

* `Ball` : `sturct obj` 형의 `Ball`이란 구조체 변수를 정의하란 뜻.
	- `main` 함수에서 `struct obj Ball;`라고 쓰는 것과 동일.

```c
/* 멤버를 쉽게 초기화 하기*/
#include <stdio.h>
int Print_Status(struct HUMAN human);
struct HUMAN {
  int age;
  int height;
  int weight;
  int gender;
};

int main() {
  struct HUMAN Adam = {31, 182, 75, 0};
  struct HUMAN Eve = {27, 166, 48, 1};

  Print_Status(Adam);
  Print_Status(Eve);
}

int Print_Status(struct HUMAN human) {
  if (human.gender == 0) {
    printf("MALE \n");
  } else {
    printf("FEMALE \n");
  }

  printf("AGE : %d / Height : %d / Weight : %d \n", human.age, human.height,
         human.weight);

  if (human.gender == 0 && human.height >= 180) {
    printf("HE IS A WINNER!! \n");
  } else if (human.gender == 0 && human.height < 180) {
    printf("HE IS A LOSER!! \n");
  }

  printf("------------------------------------------- \n");

  return 0;
}
```

* 중활호를 통해 순차적으로 포인터 변수의 멤버의 값을 대입할 수 있다.
* 이전 예제와 조합.
	- ```c
	struct HUMAN {
  int age;
  int height;
  int weight;
  int gender;
} Adam = {31, 182, 75, 0}, Eve = {27, 166, 48, 1};
	```

#### 공용체 (union)

```c
/* 공용체 */
#include <stdio.h>
union A {
  int i;
  char j;
};
int main() {
  union A a;
  a.i = 0x12345678;
  printf("%x", a.j);
  return 0;
}
```

* 공용체는 구조체와 달리 메모리를 공유한다.
	- https://modoocode.com/img/1210640D4C14DC693AF455.webp
* 각 멤버의 메모리 시작 주소가 동일하다.
	- `j`의 값을 변경함으로써 `i`의 값도 변경할 수가 있다.
* `0x12345678` 대입시 `0x12`가 아닌 `0x78`이 나온다.

#### 빅 엔디안 (Big Endian), 리틀 엔디안 (Little Endian)

* 빅 엔디안 방식 : 컴퓨터에서 메모리에 수를 저장할 때 즉 낮은 주소값에 상위 비트를 적는 방식.
	- 보통 우리가 생각하는 방법.
	- https://modoocode.com/img/15149E0E4C14DC6A3AB3FF.webp
	- 메모리 앞에서부터 수를 저장한다.
	- `12``34``56``78`
* 리틀 엔디안 방식 : 높은 주소값에 상위 비트를 적는 방식
	- https://modoocode.com/img/122BC3054C14DC6B87546A.webp
	- 메모리 뒤에서 부터 역으로 수를 저장한다.
	- `78``56``34``12`
	- 리틀 엔디안 방식으로 저장된 데이터를 출력할 때는 적절한 변환을 거쳐 빅 엔디안 방식으로 출력한다.
* 대부분 `x86` 프로레서가 리틀 엔디안 방식을 사용하고 있다.

#### 열거형 (Enum)

```c
/* 열거형의 도입 */
#include <stdio.h>
enum { RED, BLUE, WHITE, BLACK };
int main() {
  int palette = RED;
  switch (palette) {
    case RED:
      printf("palette : RED \n");
      break;
    case BLUE:
      printf("palette : BLUE \n");
      break;

    case WHITE:
      printf("palette : WHITE \n");
      break;
    case BLACK:
      printf("palette : BLACK \n");
      break;
  }
}
```

* 각 데이터를 수를 대응할 때 헷갈리는 경우가 생긴다. ex) 남자는 0, 여자는 1.
* 하나하나 상수를 설정하는 대신 열거형을 도입하면 편리하다.
* `enum`을 쓰고 중괄호 안에 각각에 대해 작성한다.
* `enum` 문법
	- 컴파일러는 각 원소에 0부터 차례로 정수값을 매긴다.
		- `RED = 0, BULE = 1, BLACK = 3...`
	- `if (palette == 0)` == `if (palette == RED)`
		- 컴파일러 시 `RED`는 모두 0으로 바뀌게 된다.
		- `RED`라는 변수가 메모리에 저장되는 것은 아니다.
	- 열거형을 원하는 수로 지정해줄 수 있다.
		- `enum { RED = 3, BLUE, WHITE, BLACK };`
		- 중복하는 것도 가능
			- `enum { RED = 3, BLUE, WHITE = 3, BLACK }`
				- 이 경우 수를 지정한 부분부터 다시 시작된다.
				- `BLUE = 4, BLACK = 4`
---

#### 나도 코딩 구조체
```c
#include <stdio.h>

struct GameInfo
{
	char* name;
	int year;
	int price;
	char* company;
};

int main()
{
struct GameInfo gameInfo1;
	
	gameInfo1.name = "나도게임";
	gameInfo1.year = 2017;
	gameInfo1.price = 50;
	gameInfo1.company = "나도회사";

	struct GameInfo gameInfo2 = { "게임게임", 2020, 100, "나거히소" };

	return 0;
}
```

* struct를 사용해서 구조체 선언
* 파이썬 클래스와 비슷
* 구조체를 자료형(?)을 선언하고 중괄호 안에 값들을 넣으면 차례대로 초기화된다. 

```c
	struct GameInfo gameArray[2] = { 
	{ "게임게임", 2020, 100, "나거히소" },
	{ "게게게임임", 2018, 190, "메피비즘" }
	};
```

* 배열로도 구조체를 만들 수 있음.

```c
	struct GameInfo *gamePtr;
	gamePtr = &gameInfo1;
	printf("포인터 \n");
	printf("  게임명 : %s\n", (*gamePtr).name);
	printf("  게임명 : %d\n", (*gamePtr).year);
	printf("  게임명 : %d\n", (*gamePtr).price);
	printf("  게임명 : %s\n", (*gamePtr).company);

	printf("  게임명 : %s\n", gamePtr->name);
	printf("  게임명 : %d\n", gamePtr->year);
	printf("  게임명 : %d\n", gamePtr->price);
	printf("  게임명 : %s\n", gamePtr->company);



```

* 포인터로 구조체를 만들 수 있음.
* 주소값에 해당하는 자료(값)에 접근하기 위해서 `*`를 사용
	- 기존처럼 `*포인터변수.구조체변수`라고 쓰면 포인터변수.구조체변수의 주소값을 찾으려고 함.
	- `*`와 포인터변수를 괄호로 묶어놓아야만 정상 작용.
* `포인터변수 -> 구조체변수`같은 편리한 방식으로 접근 가능






```c

#include <stdio.h>

typedef struct //GameInfomation 
{
	char* name;
	int year;
	int price;
	char* company;
	struct GameInfo* friendGame;
} GAME_INFO;


int main()
{

	// 구조체의 구조체
	gameInfo1.friendGame = &gameInfo2;
	printf("구조체 안의 구조체\n");

	printf("  게임명 : %s\n", gameInfo1.friendGame->name);
	printf("  게임명 : %d\n", gameInfo1.friendGame->year);
	printf("  게임명 : %d\n", gameInfo1.friendGame->price);
	printf("  게임명 : %s\n", gameInfo1.friendGame->company);

	// typedef
	// 자료형에 이름 지정
	int i = 1;
	typedef int 정수;
	정수 j = 3;
	printf("%d, %d \n", i, j);

	typedef struct GameInfo 게임정보;
	게임정보 game1;
	game1.name = "한글게임1";
	game1.year = 4124;
	printf ("%d %d \n", game1.name, game1.year);

	
	GAME_INFO game2;
	game2.name = "한글 겡미2";
	game2.year = 3213;
	printf("%s %d \n", game2.name, game2.year);


	return 0;


}
```

* `typedef`
	- 자료형에 이름을 지정할 수 있게 된다.
	- `typedef` `바꾸고 싶은 자료형` `바꾸고 싶은 이름`
	- `struct 구조체 이름`같은 두 개 이상의 문장도 치환시키는 게 가능하다. 
	- 구조체를 선언할 때 앞에 `typedef`를 붙이고 중괄호 마지막에 치환할 이름을 적을 수 있다.
		- `typedef struct`처럼 구조체의 이름을 지워도 선언에는 문제 없지만 구조체 이름을 적은 코드는 에러가 난다.

---

### 17. 변수, 데이터 세그먼트의 구조

```c
#include <stdio.h>

void function() {
  int a = 2;
}

int main() {
  int a = 3;
  function();

  printf("a = %d \n", a);
}
```

* 어떠한 함수 내에서 일반적으로 정의된 변수는 해당 함수 내에서만 접근할 수 있다.
* 해당 지역에서만 접근할 수 있기에 위와 같은 변수들을 지역 변수라고 한다.
	- `main` 함수 안의 `a`와 `function` 안의 `a`는 각각 다른 변수다.
* `{}`를 기준으로 지역을 나눈다.

```c
#include <stdio.h>

int main() {
  int a = 3;
  {
    int a = 4;
    printf("a = %d \n", a);
  }

  printf("a = %d \n", a);
}
```

* 괄호 안의 `a`와 밖의 `a`는 서로 다른 `a`이다.
* 해당 지역에서 정의된 변수는 바깥 지역에서 정의된 같은 이름의 변수를 무시한다.

#### 전역 변수

```c
/* 전역 변수 */
#include <stdio.h>

int global = 0;

int function() {
  global++;
  return 0;
}
int main() {
  global = 10;
  function();
  printf("%d \n", global);
  return 0;
}
```

* 어떠한 지역(중괄호)에도 속해있지 않은 변수를 전역 변수라고 한다.
* 전역 변수는 프로그램이 시작할 때 만들어졌다가 프로그램이 종료 될 때 파괴된다.
	- 지역 변수는 함수가 종료되는 시점에 파괴된다.
* 전역 변수는 메모리의 데이터 영역(Data segment)에 할당된다.
* 모든 전역 변수는 정의 시 자동으로 0으로 초기화된다.
* 전역 변수를 많이 선언하는 것은 권장치 않는다.

#### 변수의 생존 기간 

```c
#include <stdio.h>

int* function() {
  int a = 2;
  return &a;
}

int main() {
  int* pa = function();
  printf("%d \n", *pa);
}
```

* 일반적으로 정의된 변수들은 자신이 정의된 지역을 빠져나갈 때 파괴 된다.
	- 자신이 정의된 위치를 포함하고 있는 {} 를 벗어날 때 해당 변수가 사라지게 된다.
* 위 코드의 `a`는 지역 변수이다.
	- `a`가 정의된 `function`을 빠져나가면 `a`는 소멸되어 더는 쓸 수 없게 된다.

#### 정적 변수 

```c
#include <stdio.h>

int* function() {
  static int a = 2;
  return &a;
}

int main() {
  int* pa = function();
  printf("%d \n", *pa);
}
```

* 지역을 빠져나가도 파괴되지 않는 변수를 정적 변수라고 한다.
* 일반적인 변수 선언 앞에 `static`을 붙여주면 정적 변수를 선언할 수 있다.
* 정적 변수는 자신이 선언된 범위를 벗어나더라도 절대로 파괴되지 않는다.
* 함수를 여러번 호출하더라도 정적 변수의 초기화는 딱 한 번만 초기화 된다.
	- `static int a = 2`라는 문장는 딱 한 번 실행된다.
* 함수를 실행하지 않아도 정적 변수는 이미 정의된 상태가 된다.
* 전역 변수처럼 데이터 영역에 저장되다 프로그램이 종료될 때 파괴된다.
* 특별한 값을 지정해주지 않으면 0으로 초기화된다.

#### 데이터 세그먼트의 구조

* 프로그램이 실행 될 때 프로그램은 RAM 에 적재된다.
	- 프로그램의 모든 내용이 RAM 위로 올라오게 된다.
		- 프로그램의 코드와 프로그램의 데이터를 모두 의미한다.
* RAM 위로 올라오는 프로그램의 내용을 코드 세그먼트(Code Segment)와 
데이터 세그먼트(Data Segment)로 분류할 수 있다.
* 데이터 세그먼트
	- https://modoocode.com/img/140309404D2EF2B93B6CF4.webp
	- 스택(stack)
		- 지역변수가 위치한다.
		- 지역 변수가 늘어나면 크기가 아래로 증가한다.
		- 지역변수가 파괴되면 크기는 다시 돌아온다.
		- 스택이 늘어나는 방향은 메모리 주소가 낮아지는 방향이다.
	- 힙(Heap)
		- 
	- 데이터 영역
		- 전역 변수와 정적 변수가 위치한다.
	- Read-Only Data
		- 상수와 리터럴이 위치한다.
		- 이 데이터들의 값은 절대로 변경되지 않는다.
	- 코드 영역 (Code Segment)

```c
/* 메모리의 배치 모습 */

#include <stdio.h>
int global = 3;
int main() {
	int i;
	char* str = "Hello, Baby";
	char arr[20] = "WHATTHEHECK";

	printf("global : %p \n", &global);
	printf("i : %p \n", &i);
	printf("str : %p \n", str);
	printf("arr : %p \n", arr);
}
```

* https://modoocode.com/img/114F551E4C1E3404A1F0AD.webp
* https://blog.naver.com/speciallive/98372211

---

### 18. 파일 뽀개기

#### 모듈화

```c
/*
test.c
여러분과 파일 이름은 다를 수 있습니다.
*/
#include <stdio.h>
char compare(char *str1, char *str2);
int main() {
  char str1[20];
  char str2[20];

  scanf("%s", str1);
  scanf("%s", str2);

  if (compare(str1, str2)) {
    printf("%s 와 %s 는 같은 문장 입니다. \n", str1, str2);
  } else {
    printf("%s 와 %s 는 다른 문장 입니다. \n", str1, str2);
  }
  return 0;
}
```

```c
/*
str.c
*/

char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```

*  실행 파일을 만드는 과정
	- C 코드를 컴퓨터가 이해할 수 있는 언어로 바꿔주는 컴파일(compile). 
		- 단일 소스 코드 전체를 어셈블리어 (기계어와 1 : 1 대응이 되어 있음) 로 변환한다.
		- 목적코드라 불리는 확장자가 .o 인 파일이 생성된다.
	- 링킹(linking) 이라는 과정이 진행
		-  각기 다른 파일에 위치한 소스 코드들을 한데 엮어서 하나의 실행 파일로 만들어준다.
		- 특정한 소스 파일에 있는 함수들의 위치를 찾는 과정을 거친다.
			- `test.c`의 경우 `compare` 함수의 위치를 찾는다.
		- 링커(링킹을 해주는 프로그램)은 `test.c`에서 호출한 `compare`함수를 `str.c`에서 찾는다.
* 함수가 추가될 경우 그 함수를 쓰는 다른 파일에서 함수의 원형을 써야만 한다.

#### 헤더 파일

```h
/* str.h */
char compare(char *str1, char *str2);
```

* `#include`와 같은 명령을 전처리기(Preprocessor)라고 한다.
	- 컴파일 이전에 실행된다는 특징을 가지고 있다.
* 지칭하는 파일의 내용을 정확히 복사해서 붙여넣는다.
	- `#include "str.h"`는 헤더 파일의 내용, `char compare(char *str1, char *str2);`로 컴파일이 되기 전에 바뀌어 버린다.
* `#include <stdio.h>` 역시 내용들이 정확히 복사되어 컴파일 이전에 코드로 변해버린다.
	- 컴파일러에서 기본적으로 지원하는 헤더파일은 `<>`로 표기한다.
* `str.c`에서도 `str.h`를 `include`하고 있다.

### 파일 입출력

* fputs, fgets
*  fprintf, fscanf 