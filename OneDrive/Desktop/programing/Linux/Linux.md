## linux

* 윈도우OS, MacOS 와 같은 운영체제.
* 42 서울에서 사용하는 i mac은 리눅스과 같은 unix계열.
* GUI 대신 CLI를 주로 사용하여 명령을 내린다.


## 용어 정리

- GUI(Graphical User Interface) : 아이콘을 드래그하거나 더블클릭 하는 등 익숙한 방식으로 명령을 내리는 방식.
- CLI(Command Line Interface) : 터미널에 직접 명령어를 입력해서 명령을 내리는 방식.
- 쉘(Shell) : CLI 명령을 해석하는 소프트웨어. 커널(kernel : 알맹이)의 반댓말로 껍데기라는 의미. unix/linux의 bash, windows의 cmd
- 터미널(Terminal) : 시스템에 접속하여 입출력을 가능하게 하는 단말 장치. 하드웨어와 소프트웨어 형태가 있다.
- 콘솔(Console) : 터미널의 일종. 시스템 제어 등을 위한 특수 목적의 터미널이다.


## 디렉토리와 파일

* 내리는 명령은 현재 머무는 디렉토리를 대상으로 해서 내려진다.

* chmod 명령어
    - chmod [0~7][0~7][0~7] [파일이름]
        - [파일 종류][user 권한][group 권한][other 권한]
        - 파일종류
            - - : 파일
            - d : 디렉크리
            - l : 링크
        - 권한
            - r : read
            - w : write
            - x : excute
        - 1비트씩 총 3비트의 공간 차지
        - 0과 1로 표시(0 : -)
        - [4][2][1]
    - chmod [u,g,o][`+`,`-`][r,w,x] [파일이름]

* 사용자 계정 그룹 계정

## 링크


* 소프트 링크
* 사용자가 알아보기 쉽게 저장된 링크 파일과 컴퓨터가 알아보기 쉽게 저장된 파일 시스템은 저장 방식이 다르다.
    - 두 개의 테이블을 연결하는 inode라는 인덱스 키로 파일을 일대일 맵핑시킨다.
    - inode는 파일이 생성될 때 모든 파일에 고유하게 생성되는 번호.
    - ref : 실제 파일 시스템을 참조하는 링크 파일의 개수
    - 파일이 생성될 때 ref 값은 1
*  링크 파일에서 파일을 열면 해당 파일의 inode값을 찾아 물리적 위치에 저장된 파일에 접근.
    - ref는 물리적 위치의 inode를 참조하고 있는 링크 파일의 개수를 카운팅한다.
    - 일반적인 파일의 ref은 1이기에 삭제할 때 -1을 해서 0이 되면 OS는 파일을 삭제
* 하드 링크
    - 파일 시스템에 저장된 inode값을 중복해서 만든다.
    - 참조된 값에 따라 카운팅 되는 ref
    - 원본 데이터의 복사본을 만드는 동시에 파일 시스템에서 같은 파일을 참조한다.
    - 하나라도 수정 편집 하면 참조하는 모든 파일이 수정 편집이 발생한다.
    - 하드 링크를 생성한 이후 원본과 복사본의 차이는 의미없다.
    - 삭제는 개별적으로 적용된다. 원본이 삭제되도 다른 파일에 영향을 주지 않는다.
        - ref 값이 0이 아니므로
        - 하드 링크된 파일이 하나라도 존재한다면 파일 시스템의 파일은 삭제되지 않는다.
    - 디렉토리는 하드 링크를 설정할 수 없다.
    - ln [원본 파일] [링크하고 싶은 파일]

* 소프트 링크
    - 윈도우의 바로가기 버튼과 비슷한 개념이다.
    - 링크 파일이 링크 파일을 참조하는 형식이다.
    - 파일 디렉토리 구분 없이 설정 가능하다.
    - 소프트웨어(오픈 소스 라이브러리리) 개발에 용이
        - 매번 릴리스되는 라이브러리를 매번 다운로드 하기 번거로움
        - 라이브러리를 대표하는 이름으로 소프트링크를 만들어서 배포
    - ln -s [원본 파일] [링크하고 싶은 파일(생성)]
        - 링크 파일로 원본 파일에 접근 가능


## heplp와 man

* 리눅스의 명령어들은 프로그램이다.

* [명령어] --help
    - 명령어의 사용 방법이 나온다.

* man [명령어]
    - 명령어의 사용방법이 나온다.
    - 페이지에서 `/`를 누르고 키워드를 검색할 수 있다.
        - `N`키로 탐색, `Q`키로 빠져나갈 수 있다.

* ls -a
    - 모든 파일을 보여준다.
    - 파일 앞에 `.`이 붙여져 있으면 감춰진 파일이다.

* 명령어의 파라미터는 여러 개를 쓸 수 있다.

* ls -al
    - `-a`와 `-l`의 기능이 나온다.

* ls -alS
    - 모든 파일을 크기 순서대로 정렬한다.

## 명령어를 찾는 법


* `원하는 명령` `작동하는 위치` 
    - `create dir` `in linux`

* cp [원본 파일] [복사할 위치]
    - 파일을 복사한다.
    - `/`로 디렉토리를 구분한다.

* mv [원본 파일] [이동할 파일]
    - 파일의 이름을 바꿀 때도 mv를 사용한다.

## sudo

* sudo
    - super user do의 약자
    - 사용자

* 유닉스 계열의 운영 체제는 다중 사용자 시스템
    - 여러 명이 컴퓨터를 나눠서 쓰게 되면서 접근할 수 있는 권한이 생기게 됨.
    - super user, root user라는 개념이 생김
    - 높은 권한이 요청되는 경우에 한해서만 sudo를 사용함.

## nano(vim으로 대체)

* 

## 패키지 매니저

* 앱스토어처럼 필요한 패키지를 정렬, 설치, 삭제를 도와주는 소프트웨어
* 대표적인 패키지인 apt, yum

1. 최신상태로 업데이트
    - sudo apt-get update
2. 설치하고 싶은 프로그램 탐색
    - sudo apt-cache search [검색어]
3. 설치
    - sudo apt-get install
0. 업그레이드
    - sudo apt-get upgrade [패키지]
    - 파라미터가 없을 시 전체를 업그레이드 한다.
0. 삭제
    - sudo apt-get remove [패키지]

## CLI

* GUI보다 훨씬 가벼운 CLI
* 무거운 프로젝트를 돌리기 용이
* GUL는 쉽지만 순차적으로 진행되서 오래 걸림.

* 한 줄에 여러 명령을 입력할 수 있다.
    - `mkdir why; cd why`
    - 구분은 `;`

* 한 번에 여러 명령을 실행할 수 있다는 것은 큰 이점이 된다.

* 파이프라인
    - 무언가를 한 곳에서 다른 곳으로 전송한다는 특성을 비유적으로 표현
    - 하나의 프로세스의 출력을 다른 프로세스의 입력으로 준다.
* cat [파일명]
    - 파일의 내용을 출력한다.
* grep [검색어] [파일]
    - 검색어가 포함되어 있는 단어를 강조해서 출력해 준다.

* |
    - 파이프를 이용하면 한 명령어의 출력을 다른 명령어의 입력으로 넣을 수 있다.
    - 왼쪽 명령의 출력을 오른쪽 명령의 입력으로 전달한다.
    - `ls --help | grep sort`

## IO Redirection
* Input Output Redirection
    - 입출력의 방향을 바꾼다.

* ls -l > [파일명]
    - 출력을 화면이 아닌 다른 파일로 저장시킴
        - redirection
        - ls : 프로세스
        - -l : Command-line Arument
        - 결과 : Standard Output
        - `>`로 리다이렉션

* 유닉스는 프로세스(프로그램)가 실행되면 출력하는 결과를 크게 두 가지로 구분한다. 
    - Standard Output
        - `1>`, output에 관한 정보를 출력
    - Standard Error
        - 에러 시 리다이렉션이 적용되지 않고 (아웃풋(에러 메세지)이 리다이렉션 되지 않고) 모니터에 출력을 한다.
            - `>`만 사용하면 `Standard Output`을 의미하는 `1>`로 인식되어 아무런 정보도 리다이렉션 되지 않는다. (` Standard Error`만 출력되므로)
            - `2>`를 사용해야 Standard Error에 대한 정보에 접근해 리다이렉션을 할 수 있다.
    - [명령어] 1> [Standard Output을 저장할 파일명] 2> [Standard Error를 저장할 파일명]

* 컴퓨터에 저장되어 있는 코드를 프로그램이라고 한다.
* 실행되고 있는 프로그램 상태를 프로세스라고 한다.
* 하나의 프로그램은 여러 프로세스를 가질 수 있다.
* 하나의 입력과 두 개의 출력 형태가 존재한다.

* cat
    - 키보드로 입력한 정보를 standard input으로 받고 있다.
    - `<`로 파일에 저장된 텍스트를 입력으로 넣을 수 있다.
    - cat [파일명]
        - cat 명령어의 인자로 전달한 것
    - cat < [파일명]
        - standard input으로 입력을 받은 것
    - cat [파일명] >> [파일명]
        - 출력을 모니터가 아닌 파일에 붙여넣기한다. (마지막 부분에)
* head
    - 첫번째 열 줄을 출력한다.
    - head -n1 < [입력값으로 쓸 파일명] > [출력값을 저장할 파일명]

* IO stream
    - 시냇물이 흐르듯 데이터의 입력과 출력이 유연하게 흘러가는 것을 비유한 표현.

* `>`
    - 리다이렉션, 파일 내용이 있을 경우 덮어쓰기.

* `>>`
    - 리다이렉션, 파일 내용이 있을 경우 맨 뒤에 붙여 넣는다.

* ctrl + d
    - 취소
* ctrl + c
    - 줄 지우기
* /dev/null
    - 쓰레기통
    - 리다이렉션하면 아무것도 출력하지 않는다.

## 셸과 커널

* 하드웨어의 구성
* 하드웨어 < 커널 < 쉘 < 앱
    * 하드웨어
        - 기계적인 부분, 메모리, 디스크, CPU.
    * 커널(Kernel)
        - 물리적인 기계를 직접적으로 제어하는 운영체제의 중심이 되는 코어
    * 셸(Shell)
        - 사용자가 입력한 명령을 해석하는 프로그램.
        - 사람이 이해하기 쉬운 형태의 명령어를 셸이 이해할 수 있도록 해석.
        - 셸을 대상으로 입력한 명령어는 커널이 이해할 수 있는 방식으로 전달하고 커널은 하드웨어에게 명령을 처리하도록 제어. 처리 결과는 다시 하드웨어에서 커널로, 커널에서 셸로.

## 셸 스크립트

* 여러 개의 명령을 어딘가에 저장하고 불러올 수 있다.
* 여러 자동화 작업을 처리할 수 있고 명령어들 또한 셸 스크립트처럼 작동한다.

* `*`.[확장자]
    - 와일드 카드
    - [확장자] 이름으로 시작하는 모든 파일 선택

## 디렉토리의 구조

* 데이터 또는 실행할 수 있는 프로그램을 정리정돈하는 수단
* 최상위의 디렉토리를 root라고 한다.
    - /bin
        - binaries
        - 이진수를 줄여서 bin이라고 한다.
        - 사용자가 실행가능한 프로그램을 bin이라고 하기도 한다.
    - /sbin
        - system binaries
        - 시스템을 관리하는 프로그램의 집합이다.
    - /etc
        - configuration
        - 리눅스에서 설정을 바꾼다는 것은 파일을 바꾸는 것.
        - 동작하는 설정에 대한 것을 바꿀 수 있다.
    - /dev
    - /proc

    - /var
        - variable
        - 변할 수 있는 파일
    - /tmp
        - tmeporary
        - 임시로 저장되는 파일
        - 시스템 종료 시 삭제된다.
    - /home
        - 사용자의 파일들이 저장되는 디렉토리
    - /lib
        - 라이브러리가 보관되는 디렉토리
## 프로세스

* 스토리지
    - SSD, HHD.
    - 가격이 싸다.
    - 저장용량이 크다.
    - 속도가 느리다.
* 메모리
    - RAM
    - 가격이 비싸다.
    - 저장용량이 적다.
    - 속도가 빠르다.
* 프로세서
    - CPU (중앙처리장치)
* 필요한 프로그램을 스토리지에서 메모리에 올린다.
* cpu는 메모리에 있는 프로그램을 읽어서 처리를 한다.
* 프로세스 : 사용자가 입력하는 명령어, command
    - /bin이나 /sbin과 같은 파일의 형태로 스토리지에 저장되어 있다.
* 프로그램 : 컴퓨터 상에 파일의 형태로 저장된 프로세스.
* 프로세서 : 메모리에 적재된 프로그램을 프로세서에 의해 처리되는 상태
        
## 파일 찾기

* find [디렉토리]
    - 해당 디렉토리 하위에 있는 파일을 전부 보여준다.

## 백그라운드 실행

* ctrl + z
    - 실행중인 프로그램을 백그라운드로 보낼 수 있다.
* jobs
    - 백그라운드의 프로그램을 보여준다.
* fg %[n]
    - fg만 입력하면 +마크가 있는 프로그램을, n으로 인덱싱에 접근 할 수 있다.
* kill &[n]
    - kill %[n]으로 백그라운드의 프로그램을 종료할 수 있다.
* ls -R

    

## 명령어 모음

* https://www.youtube.com/watch?v=9_KIdQ8abH4&feature=emb_title

* chmod [u,g,o][`+`,`-`][r,w,x] [파일이름]
* chmod [0~7][0~7][0~7] [파일이름] 
    - 실행 권한을 변경한다.

* mkdir [파일명]
    - 디렉토리를 만든다

* touch [파일명]
    - 빈 파일을 만든다.

* rm
    - rm -f [파일명]
    - rm -R [디렉토리명]
        - 파일이나 디렉토리를 삭제한다.

* cp 
    -cp [원본 파일] [복사할 위치]
    -cp -R [원본 디렉토리] [복사할 위치]
        - 파일을 복사한다.
        - `/`로 디렉토리를 구분한다.
        - 위치를 지정하지 않으면 동일 디렉토리에 복사한다.

* mv [원본 파일] [이동할 파일]
    - 파일의 이름을 바꿀 때도 mv를 사용한다.

* cd
    - 초기 주소로 돌아간다.

* pwd
    - 현재 위치한 디렉토리를 확인할 수 있다.

* ls
    - 디렉토리 아래에 있는 파일과 디렉토리를 볼 수 있다.

    - -l [디렉토리]
        - 좀 더 자세하게 파일과 디렉토리를 볼 수 있다.
        - `ls`뒤에 넣은 `-l`을 파라미터라고 한다.
        - 앞에 d가 붙어 있으면 디렉토리란 뜻.
    - -a
        - fdsf
    - -S
        - fsdf

* `>`
    - 리다이렉션, 파일 내용이 있을 경우 덮어쓰기.
* `>>`
    - 리다이렉션, 파일 내용이 있을 경우 맨 뒤에 붙여 넣는다.

* [명령어] --help
    - 명령어의 사용 방법이 나온다.

* man [명령어]
    - 명령어의 사용방법이 나온다.
    - 페이지에서 `/`를 누르고 키워드를 검색할 수 있다.
        - `N`키로 탐색, `Q`키로 빠져나갈 수 있다.

* more [파일 이름]
    - 화면에 내용 출력

* head [파일 이름]
    - 처음부터 10줄 출력
* tail [파일 이름]
    - 끝에서부터 10줄 출력
    - tail -f filename
        - 파일의 마지막에 데이터가 추가되는 즉시 출력됨

* grep [문자열] [파일 이름]
    - 검색하고자 하는 문자가 포함된 파일을 찾아줌
    - grep -H
        - 자세한 검색
    - grep -w
        - 정확한 검색

* less
    - vi, vim과 같은 텍스트 편집 프로세스
    - 용량이 파일을 내가 원하는 만큼만 확인 가능, 메모리 절약
    
* tar
    - 압축
    - tar cvfz [압축 파일 이름].tar.gz ./[파일] ./[파일]~~~ 

* chown
    - sudo chown [개인사용자] [그룹명] [파일명]

* find
    - find [경로] [조건] [타겟]

* which
    - which [명령어]
        - 명령어의 위치를 찾아줌
        - 쉘 명령어 사용 시 필요

* whereis [명령어]
    - 명령어의 위치를 찾아줌

* top
    - cpu 상태를 확인 가능

* ping
    - ping [도메인 주소]

* ps -ef
    - 서버에서 구동중인 모든 프로세스 출력